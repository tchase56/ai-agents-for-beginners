<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f0deef171fc3a68d5d3d770a8bfb03d",
  "translation_date": "2025-08-30T13:31:22+00:00",
  "source_file": "09-metacognition/README.md",
  "language_code": "fa"
}
-->
[![طراحی چندعاملی](../../../translated_images/lesson-9-thumbnail.38059e8af1a5b71d890c92f576f933c6a307c691339dca7e8ca6ea75a8d857a1.fa.png)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(برای مشاهده ویدئوی این درس روی تصویر بالا کلیک کنید)_
# فراشناخت در عوامل هوش مصنوعی

## مقدمه

به درس فراشناخت در عوامل هوش مصنوعی خوش آمدید! این فصل برای مبتدیانی طراحی شده است که کنجکاو هستند بدانند چگونه عوامل هوش مصنوعی می‌توانند درباره فرآیندهای فکری خود فکر کنند. در پایان این درس، مفاهیم کلیدی را درک خواهید کرد و با مثال‌های عملی برای به‌کارگیری فراشناخت در طراحی عوامل هوش مصنوعی مجهز خواهید شد.

## اهداف یادگیری

پس از اتمام این درس، قادر خواهید بود:

1. پیامدهای حلقه‌های استدلال در تعریف عوامل را درک کنید.
2. از تکنیک‌های برنامه‌ریزی و ارزیابی برای کمک به عوامل خوداصلاح‌گر استفاده کنید.
3. عوامل خود را طراحی کنید که بتوانند کد را برای انجام وظایف دستکاری کنند.

## مقدمه‌ای بر فراشناخت

فراشناخت به فرآیندهای شناختی سطح بالاتری اشاره دارد که شامل فکر کردن درباره تفکر خود فرد است. برای عوامل هوش مصنوعی، این به معنای توانایی ارزیابی و تنظیم اقدامات خود بر اساس خودآگاهی و تجربیات گذشته است. فراشناخت، یا "فکر کردن درباره فکر کردن"، یک مفهوم مهم در توسعه سیستم‌های هوش مصنوعی عاملی است. این شامل آگاهی سیستم‌های هوش مصنوعی از فرآیندهای داخلی خود و توانایی نظارت، تنظیم و تطبیق رفتارشان است. درست مانند زمانی که ما محیط را ارزیابی می‌کنیم یا به یک مسئله نگاه می‌کنیم. این خودآگاهی می‌تواند به سیستم‌های هوش مصنوعی کمک کند تصمیمات بهتری بگیرند، خطاها را شناسایی کنند و عملکرد خود را در طول زمان بهبود بخشند - که دوباره به آزمون تورینگ و بحث درباره اینکه آیا هوش مصنوعی قرار است کنترل را به دست بگیرد، مرتبط می‌شود.

در زمینه سیستم‌های هوش مصنوعی عاملی، فراشناخت می‌تواند به حل چندین چالش کمک کند، از جمله:
- شفافیت: اطمینان از اینکه سیستم‌های هوش مصنوعی می‌توانند استدلال و تصمیمات خود را توضیح دهند.
- استدلال: افزایش توانایی سیستم‌های هوش مصنوعی در ترکیب اطلاعات و اتخاذ تصمیمات منطقی.
- تطبیق‌پذیری: امکان تنظیم سیستم‌های هوش مصنوعی با محیط‌های جدید و شرایط متغیر.
- ادراک: بهبود دقت سیستم‌های هوش مصنوعی در شناسایی و تفسیر داده‌ها از محیط خود.

### فراشناخت چیست؟

فراشناخت، یا "فکر کردن درباره فکر کردن"، یک فرآیند شناختی سطح بالا است که شامل خودآگاهی و خودتنظیمی فرآیندهای شناختی فرد می‌شود. در حوزه هوش مصنوعی، فراشناخت به عوامل این امکان را می‌دهد که استراتژی‌ها و اقدامات خود را ارزیابی و تطبیق دهند، که منجر به بهبود توانایی‌های حل مسئله و تصمیم‌گیری می‌شود. با درک فراشناخت، می‌توانید عوامل هوش مصنوعی طراحی کنید که نه تنها هوشمندتر بلکه تطبیق‌پذیرتر و کارآمدتر باشند. در فراشناخت واقعی، شما شاهد استدلال صریح هوش مصنوعی درباره استدلال خود خواهید بود.

مثال: "من پروازهای ارزان‌تر را اولویت دادم چون... ممکن است پروازهای مستقیم را از دست داده باشم، پس اجازه دهید دوباره بررسی کنم."
پیگیری اینکه چگونه یا چرا یک مسیر خاص را انتخاب کرده است.
- توجه به اینکه اشتباهاتی مرتکب شده چون بیش از حد به ترجیحات کاربر از دفعه قبل تکیه کرده است، بنابراین استراتژی تصمیم‌گیری خود را تغییر می‌دهد نه فقط توصیه نهایی.
- تشخیص الگوهایی مانند: "هر وقت کاربر از 'خیلی شلوغ' صحبت می‌کند، نباید فقط برخی جاذبه‌ها را حذف کنم بلکه باید بازتاب دهم که روش من برای انتخاب 'جاذبه‌های برتر' ناقص است اگر همیشه بر اساس محبوبیت رتبه‌بندی کنم."

### اهمیت فراشناخت در عوامل هوش مصنوعی

فراشناخت به دلایل متعددی نقش حیاتی در طراحی عوامل هوش مصنوعی ایفا می‌کند:

![اهمیت فراشناخت](../../../translated_images/importance-of-metacognition.b381afe9aae352f7734c8628ea3f4b23084634b791c5a120c76a02bb7eeeb7ec.fa.png)

- خودبازتابی: عوامل می‌توانند عملکرد خود را ارزیابی کرده و زمینه‌های بهبود را شناسایی کنند.
- تطبیق‌پذیری: عوامل می‌توانند استراتژی‌های خود را بر اساس تجربیات گذشته و محیط‌های متغیر تنظیم کنند.
- اصلاح خطا: عوامل می‌توانند به طور خودکار خطاها را شناسایی و اصلاح کنند، که منجر به نتایج دقیق‌تر می‌شود.
- مدیریت منابع: عوامل می‌توانند استفاده از منابع، مانند زمان و قدرت محاسباتی، را با برنامه‌ریزی و ارزیابی اقدامات خود بهینه کنند.

## اجزای یک عامل هوش مصنوعی

قبل از ورود به فرآیندهای فراشناختی، ضروری است که اجزای اساسی یک عامل هوش مصنوعی را درک کنید. یک عامل هوش مصنوعی معمولاً شامل موارد زیر است:

- شخصیت: شخصیت و ویژگی‌های عامل که نحوه تعامل آن با کاربران را تعریف می‌کند.
- ابزارها: قابلیت‌ها و عملکردهایی که عامل می‌تواند انجام دهد.
- مهارت‌ها: دانش و تخصصی که عامل دارد.

این اجزا با هم کار می‌کنند تا یک "واحد تخصصی" ایجاد کنند که بتواند وظایف خاصی را انجام دهد.

**مثال**:
یک عامل مسافرتی را در نظر بگیرید که نه تنها تعطیلات شما را برنامه‌ریزی می‌کند بلکه مسیر خود را بر اساس داده‌های لحظه‌ای و تجربیات سفر مشتریان گذشته تنظیم می‌کند.

### مثال: فراشناخت در یک سرویس عامل مسافرتی

تصور کنید که در حال طراحی یک سرویس عامل مسافرتی مبتنی بر هوش مصنوعی هستید. این عامل، "عامل مسافرتی"، به کاربران در برنامه‌ریزی تعطیلاتشان کمک می‌کند. برای گنجاندن فراشناخت، عامل مسافرتی باید اقدامات خود را بر اساس خودآگاهی و تجربیات گذشته ارزیابی و تنظیم کند. در اینجا نحوه ایفای نقش فراشناخت آورده شده است:

#### وظیفه فعلی

وظیفه فعلی کمک به یک کاربر برای برنامه‌ریزی سفری به پاریس است.

#### مراحل انجام وظیفه

1. **جمع‌آوری ترجیحات کاربر**: از کاربر درباره تاریخ‌های سفر، بودجه، علایق (مانند موزه‌ها، غذا، خرید) و هرگونه نیاز خاص سؤال کنید.
2. **بازیابی اطلاعات**: جستجوی گزینه‌های پرواز، اقامتگاه‌ها، جاذبه‌ها و رستوران‌هایی که با ترجیحات کاربر مطابقت دارند.
3. **تولید توصیه‌ها**: ارائه یک برنامه سفر شخصی‌سازی‌شده با جزئیات پرواز، رزرو هتل و فعالیت‌های پیشنهادی.
4. **تنظیم بر اساس بازخورد**: از کاربر درباره توصیه‌ها بازخورد بگیرید و تنظیمات لازم را انجام دهید.

#### منابع مورد نیاز

- دسترسی به پایگاه‌های داده رزرو پرواز و هتل.
- اطلاعات درباره جاذبه‌ها و رستوران‌های پاریس.
- داده‌های بازخورد کاربران از تعاملات قبلی.

#### تجربه و خودبازتابی

عامل مسافرتی از فراشناخت برای ارزیابی عملکرد خود و یادگیری از تجربیات گذشته استفاده می‌کند. برای مثال:

1. **تحلیل بازخورد کاربر**: عامل مسافرتی بازخورد کاربران را بررسی می‌کند تا مشخص کند کدام توصیه‌ها مورد استقبال قرار گرفته‌اند و کدام‌ها نه. سپس پیشنهادات آینده خود را بر این اساس تنظیم می‌کند.
2. **تطبیق‌پذیری**: اگر کاربری قبلاً از مکان‌های شلوغ خوشش نمی‌آمده، عامل مسافرتی در آینده از توصیه مکان‌های توریستی محبوب در ساعات اوج خودداری می‌کند.
3. **اصلاح خطا**: اگر عامل مسافرتی در یک رزرو قبلی اشتباهی مرتکب شده باشد، مانند پیشنهاد هتلی که کاملاً رزرو شده بود، یاد می‌گیرد که قبل از ارائه توصیه‌ها، در دسترس بودن را با دقت بیشتری بررسی کند.

#### مثال عملی برای توسعه‌دهندگان

در اینجا یک مثال ساده از کد عامل مسافرتی آورده شده است که فراشناخت را در خود جای داده است:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Search for flights, hotels, and attractions based on preferences
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Analyze feedback and adjust future recommendations
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### چرا فراشناخت مهم است

- **خودبازتابی**: عوامل می‌توانند عملکرد خود را تحلیل کرده و زمینه‌های بهبود را شناسایی کنند.
- **تطبیق‌پذیری**: عوامل می‌توانند استراتژی‌های خود را بر اساس بازخورد و شرایط متغیر تنظیم کنند.
- **اصلاح خطا**: عوامل می‌توانند به طور خودکار اشتباهات را شناسایی و اصلاح کنند.
- **مدیریت منابع**: عوامل می‌توانند استفاده از منابع، مانند زمان و قدرت محاسباتی، را بهینه کنند.

با گنجاندن فراشناخت، عامل مسافرتی می‌تواند توصیه‌های مسافرتی شخصی‌تر و دقیق‌تری ارائه دهد و تجربه کلی کاربر را بهبود بخشد.

---

## 2. برنامه‌ریزی در عوامل

برنامه‌ریزی یک مؤلفه حیاتی از رفتار عوامل هوش مصنوعی است. این شامل ترسیم مراحل لازم برای دستیابی به یک هدف، با در نظر گرفتن وضعیت فعلی، منابع و موانع احتمالی است.

### عناصر برنامه‌ریزی

- **وظیفه فعلی**: تعریف واضح وظیفه.
- **مراحل انجام وظیفه**: تقسیم وظیفه به مراحل قابل مدیریت.
- **منابع مورد نیاز**: شناسایی منابع ضروری.
- **تجربه**: استفاده از تجربیات گذشته برای اطلاع‌رسانی برنامه‌ریزی.

**مثال**:
در اینجا مراحلی که عامل مسافرتی باید برای کمک به کاربر در برنامه‌ریزی سفر خود به طور مؤثر انجام دهد آورده شده است:

### مراحل برای عامل مسافرتی

1. **جمع‌آوری ترجیحات کاربر**
   - از کاربر جزئیاتی درباره تاریخ‌های سفر، بودجه، علایق و هرگونه نیاز خاص بپرسید.
   - مثال‌ها: "چه زمانی قصد سفر دارید؟" "محدوده بودجه شما چقدر است؟" "در تعطیلات از چه فعالیت‌هایی لذت می‌برید؟"

2. **بازیابی اطلاعات**
   - جستجوی گزینه‌های سفر مرتبط بر اساس ترجیحات کاربر.
   - **پروازها**: جستجوی پروازهای موجود در محدوده بودجه و تاریخ‌های ترجیحی کاربر.
   - **اقامتگاه‌ها**: یافتن هتل‌ها یا املاک اجاره‌ای که با ترجیحات کاربر برای مکان، قیمت و امکانات مطابقت دارند.
   - **جاذبه‌ها و رستوران‌ها**: شناسایی جاذبه‌ها، فعالیت‌ها و گزینه‌های غذاخوری محبوب که با علایق کاربر همخوانی دارند.

3. **تولید توصیه‌ها**
   - اطلاعات بازیابی‌شده را به یک برنامه سفر شخصی‌سازی‌شده تبدیل کنید.
   - جزئیاتی مانند گزینه‌های پرواز، رزرو هتل و فعالیت‌های پیشنهادی را ارائه دهید و مطمئن شوید که توصیه‌ها با ترجیحات کاربر هماهنگ هستند.

4. **ارائه برنامه سفر به کاربر**
   - برنامه سفر پیشنهادی را برای بررسی به کاربر ارائه دهید.
   - مثال: "در اینجا یک برنامه سفر پیشنهادی برای سفر شما به پاریس آورده شده است. این شامل جزئیات پرواز، رزرو هتل و لیستی از فعالیت‌ها و رستوران‌های پیشنهادی است. نظرتان را به من بگویید!"

5. **جمع‌آوری بازخورد**
   - از کاربر درباره برنامه سفر پیشنهادی بازخورد بگیرید.
   - مثال‌ها: "آیا گزینه‌های پرواز را دوست دارید؟" "آیا هتل برای نیازهای شما مناسب است؟" "آیا فعالیت‌هایی وجود دارد که بخواهید اضافه یا حذف کنید؟"

6. **تنظیم بر اساس بازخورد**
   - برنامه سفر را بر اساس بازخورد کاربر اصلاح کنید.
   - تغییرات لازم را در توصیه‌های پرواز، اقامتگاه و فعالیت‌ها ایجاد کنید تا بهتر با ترجیحات کاربر مطابقت داشته باشد.

7. **تأیید نهایی**
   - برنامه سفر به‌روزشده را برای تأیید نهایی به کاربر ارائه دهید.
   - مثال: "من تغییرات را بر اساس بازخورد شما انجام دادم. در اینجا برنامه سفر به‌روزشده است. آیا همه چیز خوب به نظر می‌رسد؟"

8. **رزرو و تأیید نهایی**
   - پس از تأیید کاربر، رزرو پروازها، اقامتگاه‌ها و هر فعالیت از پیش برنامه‌ریزی‌شده را انجام دهید.
   - جزئیات تأیید را برای کاربر ارسال کنید.

9. **ارائه پشتیبانی مداوم**
   - در دسترس باشید تا به کاربر در صورت نیاز به تغییرات یا درخواست‌های اضافی قبل و در طول سفر کمک کنید.
   - مثال: "اگر در طول سفر به کمک بیشتری نیاز داشتید، هر زمان با من تماس بگیرید!"

### مثال تعامل

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage within a booing request
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. سیستم اصلاحی RAG

ابتدا بیایید تفاوت بین ابزار RAG و بارگذاری پیشگیرانه زمینه را درک کنیم.

![RAG در مقابل بارگذاری زمینه](../../../translated_images/rag-vs-context.9eae588520c00921f531e4dc788992e8a7b69b6ff7c9eaa69fb9bc83ad243504.fa.png)

### تولید تقویت‌شده با بازیابی (RAG)

RAG یک سیستم بازیابی را با یک مدل تولیدی ترکیب می‌کند. هنگامی که یک پرسش مطرح می‌شود، سیستم بازیابی اسناد یا داده‌های مرتبط را از یک منبع خارجی بازیابی می‌کند و این اطلاعات بازیابی‌شده برای تقویت ورودی مدل تولیدی استفاده می‌شود. این به مدل کمک می‌کند پاسخ‌های دقیق‌تر و مرتبط‌تر با زمینه تولید کند.

در یک سیستم RAG، عامل اطلاعات مرتبط را از یک پایگاه دانش بازیابی کرده و از آن برای تولید پاسخ‌ها یا اقدامات مناسب استفاده می‌کند.

### رویکرد اصلاحی RAG

رویکرد اصلاحی RAG بر استفاده از تکنیک‌های RAG برای اصلاح خطاها و بهبود دقت عوامل هوش مصنوعی تمرکز دارد. این شامل:

1. **تکنیک پرسش‌گذاری**: استفاده از پرسش‌های خاص برای هدایت عامل در بازیابی اطلاعات مرتبط.
2. **ابزار**: پیاده‌سازی الگوریتم‌ها و مکانیزم‌هایی که به عامل امکان ارزیابی ارتباط اطلاعات بازیابی‌شده و تولید پاسخ‌های دقیق را می‌دهد.
3. **ارزیابی**: ارزیابی مداوم عملکرد عامل و ایجاد تنظیمات برای بهبود دقت و کارایی.

#### مثال: RAG اصلاحی در یک عامل جستجو

یک عامل جستجو را در نظر بگیرید که اطلاعات را از وب برای پاسخ به پرسش‌های کاربر بازیابی می‌کند. رویکرد RAG اصلاحی ممکن است شامل موارد زیر باشد:

1. **تکنیک پرسش‌گذاری**: فرموله کردن پرسش‌های جستجو بر اساس ورودی کاربر.
2. **ابزار**: استفاده از پردازش زبان طبیعی و الگوریتم‌های یادگیری ماشین برای رتبه‌بندی و فیلتر کردن نتایج جستجو.
3. **ارزیابی**: تحلیل بازخورد کاربر برای شناسایی و اصلاح نادرستی‌ها در اطلاعات بازیابی‌شده.

### RAG اصلاحی در عامل مسافرتی

RAG اصلاحی (تولید تقویت‌شده با بازیابی) توانایی هوش مصنوعی را برای بازیابی و تولید اطلاعات در حالی که نادرستی‌ها را اصلاح می‌کند، افزایش می‌دهد. بیایید ببینیم چگونه عامل مسافرتی می‌تواند از رویکرد RAG اصلاحی برای ارائه توصیه‌های مسافرتی دقیق‌تر و مرتبط‌تر استفاده کند.

این شامل موارد زیر است:

- **تکنیک پرسش‌گذاری:** استفاده از پرسش‌های خاص برای هدایت عامل در بازیابی اطلاعات مرتبط.
- **ابزار:** پیاده‌سازی الگوریتم‌ها و مکانیزم‌هایی که به عامل امکان ارزیابی ارتباط اطلاعات بازیابی‌شده و تولید پاسخ‌های دقیق را می‌دهد.
- **ارزیابی:** ارزیابی مداوم عملکرد عامل و ایجاد تنظیمات برای بهبود دقت و کارایی.

#### مراحل پیاده‌سازی RAG اصلاحی در عامل مسافرتی

1. **تعامل اولیه با کاربر**
   - عامل مسافرتی ترجیحات اولیه کاربر را جمع‌آوری می‌کند، مانند مقصد، تاریخ‌های سفر، بودجه و علایق.
   - مثال:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **بازیابی اطلاعات**
   - عامل مسافرتی اطلاعاتی درباره پروازها، اقامتگاه‌ها، جاذبه‌ها و رستوران‌ها بر اساس ترجیحات کاربر بازیابی می‌کند.
   - مثال:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **تولید توصیه‌های اولیه**
   - عامل مسافرتی از اطلاعات بازیابی‌شده برای تولید یک برنامه سفر شخصی‌سازی‌شده استفاده می‌کند.
   - مثال:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **جمع‌آوری بازخورد کاربر**
   - عامل مسافرتی از کاربر درباره توصیه‌های اولیه بازخورد می‌گیرد.
   - مثال:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **فرآیند RAG اصلاحی**
   - **تکنیک پرسش‌گذاری**: عامل مسافرتی پرسش‌های جستجوی جدیدی بر اساس بازخورد کاربر فرموله می‌کند.
     - مثال:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **ابزار**: عامل مسافرتی از الگوریتم‌ها برای رتبه‌بندی و فیلتر کردن نتایج جستجوی جدید استفاده می‌کند و بر ارتباط بر اساس بازخورد کاربر تأکید می‌کند.
     - مثال:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **ارزیابی**: عامل مس
```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### بارگذاری پیش‌زمینه به صورت پیش‌گیرانه

بارگذاری پیش‌زمینه به صورت پیش‌گیرانه شامل بارگذاری اطلاعات مرتبط یا زمینه‌ای در مدل قبل از پردازش یک پرسش است. این به این معناست که مدل از ابتدا به این اطلاعات دسترسی دارد، که می‌تواند به تولید پاسخ‌های آگاهانه‌تر کمک کند بدون اینکه نیاز به بازیابی داده‌های اضافی در طول فرآیند باشد.

در اینجا یک مثال ساده از نحوه بارگذاری پیش‌زمینه برای یک برنامه آژانس مسافرتی در پایتون آورده شده است:

```python
class TravelAgent:
    def __init__(self):
        # Pre-load popular destinations and their information
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Fetch destination information from pre-loaded context
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Example usage
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### توضیحات

1. **مقدمه‌سازی (متد `__init__`)**: کلاس `TravelAgent` یک دیکشنری شامل اطلاعاتی درباره مقصدهای محبوب مانند پاریس، توکیو، نیویورک و سیدنی را بارگذاری می‌کند. این دیکشنری شامل جزئیاتی مانند کشور، ارز، زبان و جاذبه‌های اصلی هر مقصد است.

2. **بازیابی اطلاعات (متد `get_destination_info`)**: زمانی که کاربر درباره یک مقصد خاص پرسش می‌کند، متد `get_destination_info` اطلاعات مرتبط را از دیکشنری بارگذاری‌شده بازیابی می‌کند.

با بارگذاری پیش‌زمینه، برنامه آژانس مسافرتی می‌تواند به سرعت به پرسش‌های کاربران پاسخ دهد بدون اینکه نیاز به بازیابی این اطلاعات از یک منبع خارجی به صورت لحظه‌ای داشته باشد. این باعث می‌شود برنامه کارآمدتر و پاسخگوتر باشد.

### شروع برنامه‌ریزی با هدف قبل از تکرار

شروع برنامه‌ریزی با هدف شامل آغاز با یک هدف واضح یا نتیجه مطلوب است. با تعریف این هدف از ابتدا، مدل می‌تواند از آن به عنوان یک اصل راهنما در طول فرآیند تکرار استفاده کند. این کمک می‌کند تا هر تکرار به دستیابی به نتیجه مطلوب نزدیک‌تر شود و فرآیند کارآمدتر و متمرکزتر باشد.

در اینجا یک مثال از نحوه شروع برنامه‌ریزی سفر با هدف قبل از تکرار برای یک آژانس مسافرتی در پایتون آورده شده است:

### سناریو

یک آژانس مسافرتی می‌خواهد یک تعطیلات سفارشی برای مشتری برنامه‌ریزی کند. هدف ایجاد یک برنامه سفر است که رضایت مشتری را بر اساس ترجیحات و بودجه او به حداکثر برساند.

### مراحل

1. تعریف ترجیحات و بودجه مشتری.
2. شروع برنامه اولیه بر اساس این ترجیحات.
3. تکرار برای بهبود برنامه، بهینه‌سازی برای رضایت مشتری.

#### کد پایتون

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Example usage
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### توضیحات کد

1. **مقدمه‌سازی (متد `__init__`)**: کلاس `TravelAgent` با لیستی از مقصدهای احتمالی که هر کدام دارای ویژگی‌هایی مانند نام، هزینه و نوع فعالیت هستند، مقداردهی اولیه می‌شود.

2. **شروع برنامه (متد `bootstrap_plan`)**: این متد یک برنامه سفر اولیه بر اساس ترجیحات و بودجه مشتری ایجاد می‌کند. این لیست مقصدها را مرور کرده و آن‌ها را به برنامه اضافه می‌کند اگر با ترجیحات مشتری مطابقت داشته باشند و در بودجه قرار بگیرند.

3. **مطابقت ترجیحات (متد `match_preferences`)**: این متد بررسی می‌کند که آیا یک مقصد با ترجیحات مشتری مطابقت دارد یا خیر.

4. **تکرار برنامه (متد `iterate_plan`)**: این متد برنامه اولیه را با تلاش برای جایگزینی هر مقصد در برنامه با یک گزینه بهتر، با توجه به ترجیحات و محدودیت‌های بودجه مشتری، بهبود می‌بخشد.

5. **محاسبه هزینه (متد `calculate_cost`)**: این متد هزینه کل برنامه فعلی را، شامل یک مقصد جدید احتمالی، محاسبه می‌کند.

#### مثال استفاده

- **برنامه اولیه**: آژانس مسافرتی یک برنامه اولیه بر اساس ترجیحات مشتری برای بازدید از جاذبه‌های دیدنی و بودجه ۲۰۰۰ دلار ایجاد می‌کند.
- **برنامه بهبود‌یافته**: آژانس مسافرتی برنامه را تکرار می‌کند و آن را برای ترجیحات و بودجه مشتری بهینه‌سازی می‌کند.

با شروع برنامه با یک هدف واضح (مثلاً به حداکثر رساندن رضایت مشتری) و تکرار برای بهبود برنامه، آژانس مسافرتی می‌تواند یک برنامه سفر سفارشی و بهینه برای مشتری ایجاد کند. این روش تضمین می‌کند که برنامه سفر از ابتدا با ترجیحات و بودجه مشتری هماهنگ باشد و با هر تکرار بهبود یابد.

### استفاده از مدل‌های زبانی بزرگ برای رتبه‌بندی مجدد و امتیازدهی

مدل‌های زبانی بزرگ (LLMs) می‌توانند برای رتبه‌بندی مجدد و امتیازدهی با ارزیابی ارتباط و کیفیت اسناد بازیابی‌شده یا پاسخ‌های تولید‌شده استفاده شوند. در اینجا نحوه عملکرد آن توضیح داده شده است:

**بازیابی**: مرحله اولیه بازیابی مجموعه‌ای از اسناد یا پاسخ‌های کاندید را بر اساس پرسش انجام می‌دهد.

**رتبه‌بندی مجدد**: مدل زبانی بزرگ این کاندیدها را ارزیابی کرده و بر اساس ارتباط و کیفیت آن‌ها را مجدداً رتبه‌بندی می‌کند. این مرحله تضمین می‌کند که اطلاعات مرتبط و با کیفیت بالا در اولویت قرار گیرند.

**امتیازدهی**: مدل زبانی بزرگ به هر کاندید امتیازی اختصاص می‌دهد که نشان‌دهنده ارتباط و کیفیت آن‌ها است. این به انتخاب بهترین پاسخ یا سند برای کاربر کمک می‌کند.

با استفاده از مدل‌های زبانی بزرگ برای رتبه‌بندی مجدد و امتیازدهی، سیستم می‌تواند اطلاعات دقیق‌تر و مرتبط‌تر ارائه دهد و تجربه کلی کاربر را بهبود بخشد.

در اینجا یک مثال از نحوه استفاده یک آژانس مسافرتی از مدل زبانی بزرگ (LLM) برای رتبه‌بندی مجدد و امتیازدهی مقصدهای سفر بر اساس ترجیحات کاربر در پایتون آورده شده است:

#### سناریو - سفر بر اساس ترجیحات

یک آژانس مسافرتی می‌خواهد بهترین مقصدهای سفر را بر اساس ترجیحات مشتری توصیه کند. مدل زبانی بزرگ به رتبه‌بندی مجدد و امتیازدهی مقصدها کمک می‌کند تا مطمئن شود گزینه‌های مرتبط‌تر ارائه شوند.

#### مراحل:

1. جمع‌آوری ترجیحات کاربر.
2. بازیابی لیستی از مقصدهای سفر احتمالی.
3. استفاده از مدل زبانی بزرگ برای رتبه‌بندی مجدد و امتیازدهی مقصدها بر اساس ترجیحات کاربر.

در اینجا نحوه به‌روزرسانی مثال قبلی برای استفاده از خدمات Azure OpenAI آورده شده است:

#### نیازمندی‌ها

1. شما باید یک اشتراک Azure داشته باشید.
2. یک منبع Azure OpenAI ایجاد کنید و کلید API خود را دریافت کنید.

#### کد مثال پایتون

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Generate a prompt for the Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Define headers and payload for the request
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Call the Azure OpenAI API to get the re-ranked and scored destinations
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Extract and return the recommendations
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Example usage
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### توضیحات کد - انتخاب ترجیحات

1. **مقدمه‌سازی**: کلاس `TravelAgent` با لیستی از مقصدهای سفر احتمالی که هر کدام دارای ویژگی‌هایی مانند نام و توضیحات هستند، مقداردهی اولیه می‌شود.

2. **دریافت توصیه‌ها (متد `get_recommendations`)**: این متد یک پرامپت برای سرویس Azure OpenAI بر اساس ترجیحات کاربر ایجاد می‌کند و یک درخواست HTTP POST به API Azure OpenAI ارسال می‌کند تا مقصدهای رتبه‌بندی‌شده و امتیازدهی‌شده دریافت شود.

3. **ایجاد پرامپت (متد `generate_prompt`)**: این متد یک پرامپت برای Azure OpenAI ایجاد می‌کند که شامل ترجیحات کاربر و لیست مقصدها است. پرامپت مدل را راهنمایی می‌کند تا مقصدها را بر اساس ترجیحات ارائه‌شده رتبه‌بندی مجدد و امتیازدهی کند.

4. **درخواست API**: کتابخانه `requests` برای ارسال یک درخواست HTTP POST به نقطه پایانی API Azure OpenAI استفاده می‌شود. پاسخ شامل مقصدهای رتبه‌بندی‌شده و امتیازدهی‌شده است.

5. **مثال استفاده**: آژانس مسافرتی ترجیحات کاربر (مثلاً علاقه به بازدید از جاذبه‌های دیدنی و فرهنگ متنوع) را جمع‌آوری کرده و از سرویس Azure OpenAI برای دریافت توصیه‌های رتبه‌بندی‌شده و امتیازدهی‌شده برای مقصدهای سفر استفاده می‌کند.

اطمینان حاصل کنید که `your_azure_openai_api_key` را با کلید API واقعی Azure OpenAI خود و `https://your-endpoint.com/...` را با URL واقعی نقطه پایانی Azure OpenAI جایگزین کنید.

با استفاده از مدل زبانی بزرگ برای رتبه‌بندی مجدد و امتیازدهی، آژانس مسافرتی می‌تواند توصیه‌های سفر شخصی‌سازی‌شده و مرتبط‌تر به مشتریان ارائه دهد و تجربه کلی آن‌ها را بهبود بخشد.

### RAG: تکنیک پرامپت در مقابل ابزار

تولید مبتنی بر بازیابی (RAG) می‌تواند هم به عنوان یک تکنیک پرامپت و هم به عنوان یک ابزار در توسعه عوامل هوش مصنوعی استفاده شود. درک تفاوت بین این دو می‌تواند به شما کمک کند تا RAG را به طور مؤثرتر در پروژه‌های خود به کار ببرید.

#### RAG به عنوان تکنیک پرامپت

**چیست؟**

- به عنوان یک تکنیک پرامپت، RAG شامل فرموله کردن پرسش‌ها یا پرامپت‌های خاص برای هدایت بازیابی اطلاعات مرتبط از یک مجموعه بزرگ یا پایگاه داده است. این اطلاعات سپس برای تولید پاسخ‌ها یا اقدامات استفاده می‌شود.

**چگونه کار می‌کند:**

1. **فرموله کردن پرامپت‌ها**: ایجاد پرامپت‌ها یا پرسش‌های ساختاریافته بر اساس وظیفه مورد نظر یا ورودی کاربر.
2. **بازیابی اطلاعات**: استفاده از پرامپت‌ها برای جستجوی داده‌های مرتبط از یک پایگاه دانش یا مجموعه داده موجود.
3. **تولید پاسخ**: ترکیب اطلاعات بازیابی‌شده با مدل‌های تولیدی هوش مصنوعی برای تولید یک پاسخ جامع و منسجم.

**مثال در آژانس مسافرتی**:

- ورودی کاربر: "می‌خواهم از موزه‌های پاریس بازدید کنم."
- پرامپت: "موزه‌های برتر در پاریس را پیدا کنید."
- اطلاعات بازیابی‌شده: جزئیات درباره موزه لوور، موزه اورسی و غیره.
- پاسخ تولید‌شده: "در اینجا چند موزه برتر در پاریس آورده شده است: موزه لوور، موزه اورسی و مرکز پمپیدو."

#### RAG به عنوان ابزار

**چیست؟**

- به عنوان یک ابزار، RAG یک سیستم یکپارچه است که فرآیند بازیابی و تولید را خودکار می‌کند و اجرای قابلیت‌های پیچیده هوش مصنوعی را برای توسعه‌دهندگان آسان‌تر می‌کند.

**چگونه کار می‌کند:**

1. **یکپارچه‌سازی**: RAG را در معماری عامل هوش مصنوعی جاسازی کنید، به طوری که بتواند به طور خودکار وظایف بازیابی و تولید را مدیریت کند.
2. **خودکارسازی**: ابزار کل فرآیند را از دریافت ورودی کاربر تا تولید پاسخ نهایی مدیریت می‌کند، بدون نیاز به پرامپت‌های صریح برای هر مرحله.
3. **کارآمدی**: عملکرد عامل را با ساده‌سازی فرآیند بازیابی و تولید بهبود می‌بخشد و پاسخ‌های سریع‌تر و دقیق‌تر ارائه می‌دهد.

**مثال در آژانس مسافرتی**:

- ورودی کاربر: "می‌خواهم از موزه‌های پاریس بازدید کنم."
- ابزار RAG: به طور خودکار اطلاعات مربوط به موزه‌ها را بازیابی کرده و پاسخ تولید می‌کند.
- پاسخ تولید‌شده: "در اینجا چند موزه برتر در پاریس آورده شده است: موزه لوور، موزه اورسی و مرکز پمپیدو."

### مقایسه

| جنبه                 | تکنیک پرامپت                                        | ابزار                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **دستی در مقابل خودکار**| فرموله کردن دستی پرامپت‌ها برای هر پرسش.               | فرآیند خودکار برای بازیابی و تولید.       |
| **کنترل**            | کنترل بیشتری بر فرآیند بازیابی ارائه می‌دهد.             | بازیابی و تولید را ساده و خودکار می‌کند.|
| **انعطاف‌پذیری**        | امکان پرامپت‌های سفارشی بر اساس نیازهای خاص.      | کارآمدتر برای پیاده‌سازی‌های بزرگ‌مقیاس.       |
| **پیچیدگی**         | نیاز به ساخت و تنظیم پرامپت‌ها دارد.                  | آسان‌تر برای یکپارچه‌سازی در معماری عامل هوش مصنوعی. |

### مثال‌های عملی

**مثال تکنیک پرامپت:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**مثال ابزار:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### ارزیابی ارتباط

ارزیابی ارتباط جنبه‌ای حیاتی از عملکرد عامل هوش مصنوعی است. این تضمین می‌کند که اطلاعات بازیابی‌شده و تولید‌شده توسط عامل مناسب، دقیق و مفید برای کاربر باشد. بیایید بررسی کنیم که چگونه می‌توان ارتباط را در عوامل هوش مصنوعی ارزیابی کرد، از جمله مثال‌های عملی و تکنیک‌ها.

#### مفاهیم کلیدی در ارزیابی ارتباط

1. **آگاهی از زمینه**:
   - عامل باید زمینه پرسش کاربر را درک کند تا اطلاعات مرتبط را بازیابی و تولید کند.
   - مثال: اگر کاربر بپرسد "بهترین رستوران‌ها در پاریس"، عامل باید ترجیحات کاربر مانند نوع غذا و بودجه را در نظر بگیرد.

2. **دقت**:
   - اطلاعات ارائه‌شده توسط عامل باید از نظر واقعی صحیح و به‌روز باشد.
   - مثال: توصیه رستوران‌های باز با نظرات خوب به جای گزینه‌های قدیمی یا بسته.

3. **قصد کاربر**:
   - عامل باید قصد کاربر را از پرسش استنباط کند تا اطلاعات مرتبط‌ترین را ارائه دهد.
   - مثال: اگر کاربر بپرسد "هتل‌های اقتصادی"، عامل باید گزینه‌های مقرون‌به‌صرفه را اولویت دهد.

4. **حلقه بازخورد**:
   - جمع‌آوری و تحلیل مداوم بازخورد کاربران به عامل کمک می‌کند فرآیند ارزیابی ارتباط خود را بهبود بخشد.
   - مثال: گنجاندن رتبه‌بندی‌ها و بازخورد کاربران درباره توصیه‌های قبلی برای بهبود پاسخ‌های آینده.

#### تکنیک‌های عملی برای ارزیابی ارتباط

1. **امتیازدهی ارتباط**:
   - به هر آیتم بازیابی‌شده بر اساس میزان تطابق آن با پرسش و ترجیحات کاربر امتیاز ارتباط اختصاص دهید.
   - مثال:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **فیلتر کردن و رتبه‌بندی**:
   - آیتم‌های غیرمرتبط را فیلتر کرده و باقی‌مانده‌ها را بر اساس امتیاز ارتباط رتبه‌بندی کنید.
   - مثال:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Return top 10 relevant items
     ```

3. **پردازش زبان طبیعی (NLP)**:
   - از تکنیک‌های NLP برای درک پرسش کاربر و بازیابی اطلاعات مرتبط استفاده کنید.
   - مثال:

     ```python
     def process_query(query):
         # Use NLP to extract key information from the user's query
         processed_query = nlp(query)
         return processed_query
     ```

4. **یکپارچه‌سازی بازخورد کاربران**:
   - بازخورد کاربران درباره توصیه‌های ارائه‌شده را جمع‌آوری کرده و از آن برای تنظیم ارزیابی ارتباط در آینده استفاده کنید.
   - مثال:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### مثال: ارزیابی ارتباط در آژانس مسافرتی

در اینجا یک مثال عملی از نحوه ارزیابی ارتباط توصیه‌های سفر توسط آژانس مسافرتی آورده شده است:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Return top 10 relevant items

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### جستجو با قصد

جستجو با قصد شامل درک و تفسیر هدف یا هدف اصلی پشت پرسش کاربر برای بازیابی و تولید اطلاعات مرتبط‌ترین و مفیدترین است. این رویکرد فراتر از تطابق ساده کلمات کلیدی است و بر درک نیازها و زمینه واقعی کاربر تمرکز دارد.

#### مفاهیم کلیدی در جستجو با قصد

1. **درک قصد کاربر**:
   - قصد کاربر را می‌توان به سه نوع اصلی دسته‌بندی کرد: اطلاعاتی، ناوبری و تراکنشی.
     - **قصد اطلاعاتی**: کاربر به دنبال اطلاعات درباره یک موضوع است (مثلاً "بهترین موزه‌های پاریس چیست؟").
     - **قصد ناوبری**: کاربر می‌خواهد به یک وب‌سایت یا صفحه خاص دسترسی پیدا کند (مثلاً "وب‌سایت رسمی موزه لوور").
     - **قصد تراکنشی**: کاربر قصد انجام یک تراکنش مانند رزرو پرواز یا خرید را دارد (مثلاً "رزرو پرواز به پاریس").

2. **آگاهی از زمینه**:
   - تحلیل زمینه پرسش کاربر به شناسایی دقیق قصد او کمک می‌کند. این شامل در نظر گرفتن تعاملات قبلی، ترجیحات کاربر و جزئیات خاص پرسش فعلی است.

3. **پردازش زبان طبیعی (NLP)**:
   - تکنیک‌های NLP برای درک و تفسیر پرسش‌های زبان طبیعی ارائه‌شده توسط کاربران استفاده می‌شود. این شامل وظایفی مانند شناسایی موجودیت‌ها، تحلیل احساسات و تجزیه پرسش است.

4. **شخصی‌سازی**:
   - شخصی‌سازی نتایج جستجو بر اساس تاریخچه، ترجیحات و بازخورد کاربر ارتباط اطلاعات بازیابی‌شده را افزایش می‌دهد.
#### مثال عملی: جستجو با نیت در Travel Agent

بیایید Travel Agent را به عنوان یک مثال بررسی کنیم تا ببینیم چگونه می‌توان جستجو با نیت را پیاده‌سازی کرد.

1. **جمع‌آوری ترجیحات کاربر**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **درک نیت کاربر**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **آگاهی از زمینه**

   ```python
   def analyze_context(query, user_history):
       # Combine current query with user history to understand context
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **جستجو و شخصی‌سازی نتایج**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Example search logic for informational intent
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Example search logic for navigational intent
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Example search logic for transactional intent
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Example personalization logic
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Return top 10 personalized results
   ```

5. **مثال استفاده**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. تولید کد به عنوان یک ابزار

عوامل تولید کد از مدل‌های هوش مصنوعی برای نوشتن و اجرای کد استفاده می‌کنند تا مسائل پیچیده را حل کرده و وظایف را خودکار کنند.

### عوامل تولید کد

عوامل تولید کد از مدل‌های تولیدی هوش مصنوعی برای نوشتن و اجرای کد استفاده می‌کنند. این عوامل می‌توانند مسائل پیچیده را حل کنند، وظایف را خودکار کنند و با تولید و اجرای کد در زبان‌های برنامه‌نویسی مختلف، بینش‌های ارزشمندی ارائه دهند.

#### کاربردهای عملی

1. **تولید خودکار کد**: تولید قطعات کد برای وظایف خاص مانند تحلیل داده، وب اسکرپینگ یا یادگیری ماشین.
2. **SQL به عنوان RAG**: استفاده از کوئری‌های SQL برای بازیابی و دستکاری داده‌ها از پایگاه‌های داده.
3. **حل مسئله**: ایجاد و اجرای کد برای حل مسائل خاص مانند بهینه‌سازی الگوریتم‌ها یا تحلیل داده‌ها.

#### مثال: عامل تولید کد برای تحلیل داده

تصور کنید که در حال طراحی یک عامل تولید کد هستید. این فرآیند می‌تواند به این شکل باشد:

1. **وظیفه**: تحلیل یک مجموعه داده برای شناسایی روندها و الگوها.
2. **مراحل**:
   - بارگذاری مجموعه داده در یک ابزار تحلیل داده.
   - تولید کوئری‌های SQL برای فیلتر و تجمیع داده‌ها.
   - اجرای کوئری‌ها و بازیابی نتایج.
   - استفاده از نتایج برای تولید بصری‌سازی‌ها و بینش‌ها.
3. **منابع مورد نیاز**: دسترسی به مجموعه داده، ابزارهای تحلیل داده و قابلیت‌های SQL.
4. **تجربه**: استفاده از نتایج تحلیل‌های گذشته برای بهبود دقت و ارتباط تحلیل‌های آینده.

### مثال: عامل تولید کد برای Travel Agent

در این مثال، ما یک عامل تولید کد طراحی می‌کنیم، Travel Agent، که به کاربران در برنامه‌ریزی سفر کمک می‌کند. این عامل می‌تواند وظایفی مانند یافتن گزینه‌های سفر، فیلتر کردن نتایج و تهیه برنامه سفر را با استفاده از هوش مصنوعی تولیدی انجام دهد.

#### مرور کلی عامل تولید کد

1. **جمع‌آوری ترجیحات کاربر**: دریافت ورودی‌های کاربر مانند مقصد، تاریخ‌های سفر، بودجه و علایق.
2. **تولید کد برای بازیابی داده‌ها**: تولید قطعات کد برای بازیابی اطلاعات درباره پروازها، هتل‌ها و جاذبه‌ها.
3. **اجرای کد تولید شده**: اجرای کد تولید شده برای دریافت اطلاعات به‌روز.
4. **تولید برنامه سفر**: ترکیب داده‌های بازیابی شده به یک برنامه سفر شخصی‌سازی شده.
5. **تنظیم بر اساس بازخورد**: دریافت بازخورد کاربر و تولید مجدد کد در صورت نیاز برای بهبود نتایج.

#### پیاده‌سازی گام به گام

1. **جمع‌آوری ترجیحات کاربر**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **تولید کد برای بازیابی داده‌ها**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Example: Generate code to search for flights based on user preferences
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Example: Generate code to search for hotels
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **اجرای کد تولید شده**

   ```python
   def execute_code(code):
       # Execute the generated code using exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **تولید برنامه سفر**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **تنظیم بر اساس بازخورد**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Adjust preferences based on user feedback
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Regenerate and execute code with updated preferences
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### استفاده از آگاهی محیطی و استدلال

استفاده از طرح‌واره جدول می‌تواند فرآیند تولید کوئری را با بهره‌گیری از آگاهی محیطی و استدلال بهبود بخشد.

در اینجا یک مثال از نحوه انجام این کار آورده شده است:

1. **درک طرح‌واره**: سیستم طرح‌واره جدول را درک کرده و از این اطلاعات برای تولید کوئری استفاده می‌کند.
2. **تنظیم بر اساس بازخورد**: سیستم ترجیحات کاربر را بر اساس بازخورد تنظیم کرده و استدلال می‌کند که کدام فیلدها در طرح‌واره باید به‌روزرسانی شوند.
3. **تولید و اجرای کوئری‌ها**: سیستم کوئری‌هایی برای بازیابی داده‌های به‌روز پرواز و هتل تولید و اجرا می‌کند.

در اینجا یک مثال کد پایتون به‌روز شده که این مفاهیم را در بر می‌گیرد آورده شده است:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Adjust preferences based on user feedback
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Reasoning based on schema to adjust other related preferences
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Custom logic to adjust preferences based on schema and feedback
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Generate code to fetch flight data based on updated preferences
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Generate code to fetch hotel data based on updated preferences
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Simulate execution of code and return mock data
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Generate itinerary based on flights, hotels, and attractions
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Example schema
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Example usage
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Regenerate and execute code with updated preferences
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### توضیح - رزرو بر اساس بازخورد

1. **آگاهی از طرح‌واره**: دیکشنری `schema` تعریف می‌کند که چگونه ترجیحات باید بر اساس بازخورد تنظیم شوند. این شامل فیلدهایی مانند `favorites` و `avoid` با تنظیمات مربوطه است.
2. **تنظیم ترجیحات (متد `adjust_based_on_feedback`)**: این متد ترجیحات را بر اساس بازخورد کاربر و طرح‌واره تنظیم می‌کند.
3. **تنظیمات مبتنی بر محیط (متد `adjust_based_on_environment`)**: این متد تنظیمات را بر اساس طرح‌واره و بازخورد شخصی‌سازی می‌کند.
4. **تولید و اجرای کوئری‌ها**: سیستم کدی برای بازیابی داده‌های به‌روز پرواز و هتل تولید کرده و اجرای این کوئری‌ها را شبیه‌سازی می‌کند.
5. **تولید برنامه سفر**: سیستم یک برنامه سفر به‌روز شده بر اساس داده‌های جدید پرواز، هتل و جاذبه‌ها ایجاد می‌کند.

با آگاه کردن سیستم از محیط و استدلال بر اساس طرح‌واره، می‌توان کوئری‌های دقیق‌تر و مرتبط‌تری تولید کرد که منجر به توصیه‌های بهتر سفر و تجربه کاربری شخصی‌سازی شده می‌شود.

### استفاده از SQL به عنوان تکنیک RAG

SQL (زبان پرس‌وجوی ساختاریافته) ابزاری قدرتمند برای تعامل با پایگاه‌های داده است. هنگامی که به عنوان بخشی از رویکرد Retrieval-Augmented Generation (RAG) استفاده می‌شود، SQL می‌تواند داده‌های مرتبط را از پایگاه‌های داده بازیابی کرده و پاسخ‌ها یا اقدامات در عوامل هوش مصنوعی را اطلاع‌رسانی و تولید کند. بیایید بررسی کنیم که چگونه می‌توان از SQL به عنوان یک تکنیک RAG در زمینه Travel Agent استفاده کرد.

#### مفاهیم کلیدی

1. **تعامل با پایگاه داده**:
   - SQL برای پرس‌وجو از پایگاه‌های داده، بازیابی اطلاعات مرتبط و دستکاری داده‌ها استفاده می‌شود.
   - مثال: بازیابی جزئیات پرواز، اطلاعات هتل و جاذبه‌ها از یک پایگاه داده سفر.

2. **ادغام با RAG**:
   - کوئری‌های SQL بر اساس ورودی و ترجیحات کاربر تولید می‌شوند.
   - داده‌های بازیابی شده برای تولید توصیه‌ها یا اقدامات شخصی‌سازی شده استفاده می‌شوند.

3. **تولید پویا کوئری**:
   - عامل هوش مصنوعی کوئری‌های SQL پویا بر اساس زمینه و نیازهای کاربر تولید می‌کند.
   - مثال: سفارشی‌سازی کوئری‌های SQL برای فیلتر کردن نتایج بر اساس بودجه، تاریخ‌ها و علایق.

#### کاربردها

- **تولید خودکار کد**: تولید قطعات کد برای وظایف خاص.
- **SQL به عنوان RAG**: استفاده از کوئری‌های SQL برای دستکاری داده‌ها.
- **حل مسئله**: ایجاد و اجرای کد برای حل مسائل.

**مثال**:
یک عامل تحلیل داده:

1. **وظیفه**: تحلیل یک مجموعه داده برای یافتن روندها.
2. **مراحل**:
   - بارگذاری مجموعه داده.
   - تولید کوئری‌های SQL برای فیلتر کردن داده‌ها.
   - اجرای کوئری‌ها و بازیابی نتایج.
   - تولید بصری‌سازی‌ها و بینش‌ها.
3. **منابع**: دسترسی به مجموعه داده، قابلیت‌های SQL.
4. **تجربه**: استفاده از نتایج گذشته برای بهبود تحلیل‌های آینده.

#### مثال عملی: استفاده از SQL در Travel Agent

1. **جمع‌آوری ترجیحات کاربر**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **تولید کوئری‌های SQL**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **اجرای کوئری‌های SQL**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **تولید توصیه‌ها**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### مثال کوئری‌های SQL

1. **کوئری پرواز**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **کوئری هتل**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **کوئری جاذبه‌ها**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

با استفاده از SQL به عنوان بخشی از تکنیک Retrieval-Augmented Generation (RAG)، عوامل هوش مصنوعی مانند Travel Agent می‌توانند داده‌های مرتبط را به صورت پویا بازیابی کرده و از آن برای ارائه توصیه‌های دقیق و شخصی‌سازی شده استفاده کنند.

### مثال متاکاگنیشن

برای نشان دادن پیاده‌سازی متاکاگنیشن، بیایید یک عامل ساده ایجاد کنیم که *فرآیند تصمیم‌گیری خود را بازتاب می‌دهد* در حالی که یک مسئله را حل می‌کند. در این مثال، سیستمی طراحی می‌کنیم که عامل تلاش می‌کند انتخاب هتل را بهینه کند، اما فرآیند استدلال خود را ارزیابی کرده و در صورت بروز خطا یا انتخاب‌های نامطلوب، استراتژی خود را تنظیم می‌کند.

#### نحوه نمایش متاکاگنیشن:

1. **تصمیم اولیه**: عامل ارزان‌ترین هتل را انتخاب می‌کند، بدون در نظر گرفتن تأثیر کیفیت.
2. **بازتاب و ارزیابی**: پس از انتخاب اولیه، عامل بررسی می‌کند که آیا هتل انتخابی "بد" بوده است یا خیر، با استفاده از بازخورد کاربر. اگر کیفیت هتل خیلی پایین باشد، عامل در مورد استدلال خود بازتاب می‌کند.
3. **تنظیم استراتژی**: عامل استراتژی خود را بر اساس بازتاب تنظیم کرده و از "ارزان‌ترین" به "بالاترین کیفیت" تغییر می‌دهد، بنابراین فرآیند تصمیم‌گیری خود را در تکرارهای آینده بهبود می‌بخشد.

در اینجا یک مثال آورده شده است:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Stores the hotels chosen previously
        self.corrected_choices = []  # Stores the corrected choices
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Available strategies

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Let's assume we have some user feedback that tells us whether the last choice was good or not
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Adjust strategy if the previous choice was unsatisfactory
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Simulate a list of hotels (price and quality)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Create an agent
agent = HotelRecommendationAgent()

# Step 1: The agent recommends a hotel using the "cheapest" strategy
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Step 2: The agent reflects on the choice and adjusts strategy if necessary
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Step 3: The agent recommends again, this time using the adjusted strategy
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### توانایی‌های متاکاگنیشن عامل

نکته کلیدی در اینجا توانایی عامل برای:
- ارزیابی انتخاب‌ها و فرآیند تصمیم‌گیری قبلی خود.
- تنظیم استراتژی بر اساس بازتاب، یعنی متاکاگنیشن در عمل.

این یک شکل ساده از متاکاگنیشن است که در آن سیستم قادر است فرآیند استدلال خود را بر اساس بازخورد داخلی تنظیم کند.

### نتیجه‌گیری

متاکاگنیشن ابزاری قدرتمند است که می‌تواند به طور قابل توجهی قابلیت‌های عوامل هوش مصنوعی را افزایش دهد. با گنجاندن فرآیندهای متاکاگنیشن، می‌توانید عواملی طراحی کنید که هوشمندتر، سازگارتر و کارآمدتر باشند. از منابع اضافی برای کشف بیشتر دنیای جذاب متاکاگنیشن در عوامل هوش مصنوعی استفاده کنید.

### سوالات بیشتری درباره الگوی طراحی متاکاگنیشن دارید؟

به [دیسکورد Azure AI Foundry](https://aka.ms/ai-agents/discord) بپیوندید تا با دیگر یادگیرندگان ملاقات کنید، در ساعات اداری شرکت کنید و سوالات خود درباره عوامل هوش مصنوعی را مطرح کنید.

## درس قبلی

[الگوی طراحی چندعاملی](../08-multi-agent/README.md)

## درس بعدی

[عوامل هوش مصنوعی در تولید](../10-ai-agents-production/README.md)

---

**سلب مسئولیت**:  
این سند با استفاده از سرویس ترجمه هوش مصنوعی [Co-op Translator](https://github.com/Azure/co-op-translator) ترجمه شده است. در حالی که ما تلاش می‌کنیم دقت را حفظ کنیم، لطفاً توجه داشته باشید که ترجمه‌های خودکار ممکن است شامل خطاها یا نادرستی‌ها باشند. سند اصلی به زبان اصلی آن باید به عنوان منبع معتبر در نظر گرفته شود. برای اطلاعات حساس، توصیه می‌شود از ترجمه حرفه‌ای انسانی استفاده کنید. ما مسئولیتی در قبال سوء تفاهم‌ها یا تفسیرهای نادرست ناشی از استفاده از این ترجمه نداریم.