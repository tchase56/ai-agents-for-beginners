<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f0deef171fc3a68d5d3d770a8bfb03d",
  "translation_date": "2025-08-29T09:24:59+00:00",
  "source_file": "09-metacognition/README.md",
  "language_code": "ur"
}
-->
[![ملٹی ایجنٹ ڈیزائن](../../../translated_images/lesson-9-thumbnail.38059e8af1a5b71d890c92f576f933c6a307c691339dca7e8ca6ea75a8d857a1.ur.png)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(اوپر دی گئی تصویر پر کلک کریں تاکہ اس سبق کی ویڈیو دیکھ سکیں)_
# AI ایجنٹس میں میٹا کوگنیشن

## تعارف

AI ایجنٹس میں میٹا کوگنیشن کے سبق میں خوش آمدید! یہ باب ان ابتدائی افراد کے لیے بنایا گیا ہے جو یہ جاننا چاہتے ہیں کہ AI ایجنٹس اپنے سوچنے کے عمل کے بارے میں کیسے سوچ سکتے ہیں۔ اس سبق کے اختتام تک، آپ اہم تصورات کو سمجھ سکیں گے اور عملی مثالوں کے ذریعے AI ایجنٹ ڈیزائن میں میٹا کوگنیشن کو لاگو کرنے کے قابل ہوں گے۔

## سیکھنے کے اہداف

اس سبق کو مکمل کرنے کے بعد، آپ درج ذیل کام کرنے کے قابل ہوں گے:

1. ایجنٹ کی تعریف میں ریزننگ لوپس کے اثرات کو سمجھنا۔
2. خود کو درست کرنے والے ایجنٹس کی مدد کے لیے منصوبہ بندی اور تشخیص کی تکنیکوں کا استعمال۔
3. ایسے ایجنٹس بنانا جو کوڈ کو تبدیل کر کے کام انجام دے سکیں۔

## میٹا کوگنیشن کا تعارف

میٹا کوگنیشن ان اعلیٰ درجے کے علمی عملوں کو کہتے ہیں جو اپنے سوچنے کے عمل کے بارے میں سوچنے پر مشتمل ہوتے ہیں۔ AI ایجنٹس کے لیے، اس کا مطلب یہ ہے کہ وہ اپنی کارروائیوں کا جائزہ لے سکیں اور خود آگاہی اور ماضی کے تجربات کی بنیاد پر انہیں ایڈجسٹ کر سکیں۔ میٹا کوگنیشن، یا "سوچنے کے بارے میں سوچنا"، ایجنٹک AI سسٹمز کی ترقی میں ایک اہم تصور ہے۔ اس میں AI سسٹمز شامل ہوتے ہیں جو اپنے اندرونی عمل سے آگاہ ہوتے ہیں اور اپنے رویے کی نگرانی، ضابطہ بندی، اور موافقت کر سکتے ہیں۔ بالکل اسی طرح جیسے ہم کسی مسئلے کو دیکھتے ہیں یا ماحول کو سمجھتے ہیں۔ یہ خود آگاہی AI سسٹمز کو بہتر فیصلے کرنے، غلطیوں کی نشاندہی کرنے، اور وقت کے ساتھ اپنی کارکردگی کو بہتر بنانے میں مدد دے سکتی ہے - جو کہ ٹورنگ ٹیسٹ اور AI کے دنیا پر قبضہ کرنے کے مباحثے سے جڑتی ہے۔

ایجنٹک AI سسٹمز کے تناظر میں، میٹا کوگنیشن کئی چیلنجز کو حل کرنے میں مدد دے سکتی ہے، جیسے:
- شفافیت: یہ یقینی بنانا کہ AI سسٹمز اپنے استدلال اور فیصلوں کی وضاحت کر سکیں۔
- استدلال: AI سسٹمز کی معلومات کو ترکیب دینے اور درست فیصلے کرنے کی صلاحیت کو بڑھانا۔
- موافقت: AI سسٹمز کو نئے ماحول اور بدلتے حالات کے مطابق ڈھالنے کی اجازت دینا۔
- ادراک: AI سسٹمز کی اپنے ماحول سے ڈیٹا کو پہچاننے اور سمجھنے کی درستگی کو بہتر بنانا۔

### میٹا کوگنیشن کیا ہے؟

میٹا کوگنیشن، یا "سوچنے کے بارے میں سوچنا"، ایک اعلیٰ درجے کا علمی عمل ہے جو خود آگاہی اور اپنے علمی عملوں کی خود ضابطہ بندی پر مشتمل ہوتا ہے۔ AI کے دائرے میں، میٹا کوگنیشن ایجنٹس کو اپنی حکمت عملیوں اور کارروائیوں کا جائزہ لینے اور انہیں ایڈجسٹ کرنے کی صلاحیت فراہم کرتی ہے، جس سے مسئلے کو حل کرنے اور فیصلے کرنے کی صلاحیتیں بہتر ہوتی ہیں۔ میٹا کوگنیشن کو سمجھ کر، آپ ایسے AI ایجنٹس ڈیزائن کر سکتے ہیں جو نہ صرف زیادہ ذہین ہوں بلکہ زیادہ موافق اور مؤثر بھی ہوں۔ حقیقی میٹا کوگنیشن میں، آپ دیکھیں گے کہ AI واضح طور پر اپنے استدلال کے بارے میں استدلال کر رہا ہے۔

مثال: "میں نے سستے فلائٹس کو ترجیح دی کیونکہ... شاید میں براہ راست فلائٹس کو نظر انداز کر رہا ہوں، تو مجھے دوبارہ چیک کرنا چاہیے۔"
یہ ٹریک رکھنا کہ اس نے کسی خاص راستے کا انتخاب کیوں کیا۔
- یہ نوٹ کرنا کہ اس نے غلطیاں کیں کیونکہ اس نے پچھلی بار صارف کی ترجیحات پر زیادہ انحصار کیا، لہٰذا یہ اپنی فیصلہ سازی کی حکمت عملی کو تبدیل کرتا ہے نہ کہ صرف آخری سفارش کو۔
- ایسے پیٹرنز کی تشخیص کرنا جیسے، "جب بھی میں دیکھتا ہوں کہ صارف 'بہت زیادہ بھیڑ' کا ذکر کرتا ہے، مجھے نہ صرف کچھ مقامات کو ہٹانا چاہیے بلکہ یہ بھی سوچنا چاہیے کہ میری 'سب سے اوپر مقامات' چننے کی طریقہ کار غلط ہے اگر میں ہمیشہ مقبولیت کے لحاظ سے درجہ بندی کرتا ہوں۔"

### AI ایجنٹس میں میٹا کوگنیشن کی اہمیت

AI ایجنٹ ڈیزائن میں میٹا کوگنیشن کئی وجوہات کی بنا پر اہم کردار ادا کرتا ہے:

![میٹا کوگنیشن کی اہمیت](../../../translated_images/importance-of-metacognition.b381afe9aae352f7734c8628ea3f4b23084634b791c5a120c76a02bb7eeeb7ec.ur.png)

- خود تشخیص: ایجنٹس اپنی کارکردگی کا جائزہ لے سکتے ہیں اور بہتری کے لیے شعبوں کی نشاندہی کر سکتے ہیں۔
- موافقت: ایجنٹس ماضی کے تجربات اور بدلتے ماحول کی بنیاد پر اپنی حکمت عملیوں کو تبدیل کر سکتے ہیں۔
- غلطی کی اصلاح: ایجنٹس خود مختار طور پر غلطیوں کا پتہ لگا سکتے ہیں اور انہیں درست کر سکتے ہیں، جس سے زیادہ درست نتائج حاصل ہوتے ہیں۔
- وسائل کا انتظام: ایجنٹس اپنے اقدامات کی منصوبہ بندی اور تشخیص کے ذریعے وقت اور کمپیوٹیشنل پاور جیسے وسائل کا بہتر استعمال کر سکتے ہیں۔

## AI ایجنٹ کے اجزاء

میٹا کوگنیٹو عملوں میں جانے سے پہلے، AI ایجنٹ کے بنیادی اجزاء کو سمجھنا ضروری ہے۔ ایک AI ایجنٹ عام طور پر درج ذیل پر مشتمل ہوتا ہے:

- شخصیت: ایجنٹ کی شخصیت اور خصوصیات، جو صارفین کے ساتھ اس کے تعامل کو بیان کرتی ہیں۔
- ٹولز: وہ صلاحیتیں اور افعال جو ایجنٹ انجام دے سکتا ہے۔
- مہارتیں: وہ علم اور مہارت جو ایجنٹ کے پاس ہے۔

یہ اجزاء مل کر ایک "ماہر یونٹ" بناتے ہیں جو مخصوص کام انجام دے سکتا ہے۔

**مثال**:
ایک ٹریول ایجنٹ پر غور کریں، ایجنٹ سروسز جو نہ صرف آپ کی چھٹیوں کی منصوبہ بندی کرتی ہیں بلکہ حقیقی وقت کے ڈیٹا اور ماضی کے صارف کے سفر کے تجربات کی بنیاد پر اپنا راستہ ایڈجسٹ کرتی ہیں۔

### مثال: ٹریول ایجنٹ سروس میں میٹا کوگنیشن

فرض کریں کہ آپ ایک AI سے چلنے والی ٹریول ایجنٹ سروس ڈیزائن کر رہے ہیں۔ یہ ایجنٹ، "ٹریول ایجنٹ"، صارفین کو ان کی چھٹیوں کی منصوبہ بندی میں مدد فراہم کرتا ہے۔ میٹا کوگنیشن کو شامل کرنے کے لیے، ٹریول ایجنٹ کو خود آگاہی اور ماضی کے تجربات کی بنیاد پر اپنی کارروائیوں کا جائزہ لینا اور ایڈجسٹ کرنا ہوگا۔ یہاں میٹا کوگنیشن کا کردار کیسے ہو سکتا ہے:

#### موجودہ کام

موجودہ کام صارف کو پیرس کے سفر کی منصوبہ بندی میں مدد فراہم کرنا ہے۔

#### کام مکمل کرنے کے مراحل

1. **صارف کی ترجیحات جمع کریں**: صارف سے ان کے سفر کی تاریخوں، بجٹ، دلچسپیوں (جیسے عجائب گھر، کھانے، خریداری)، اور کسی خاص ضروریات کے بارے میں پوچھیں۔
2. **معلومات حاصل کریں**: صارف کی ترجیحات سے میل کھانے والے فلائٹ آپشنز، رہائش، مقامات، اور ریستوران تلاش کریں۔
3. **سفارشات تیار کریں**: فلائٹ کی تفصیلات، ہوٹل کی بکنگ، اور تجویز کردہ سرگرمیوں کے ساتھ ایک ذاتی نوعیت کا سفر نامہ فراہم کریں۔
4. **فیڈبیک کی بنیاد پر ایڈجسٹ کریں**: سفارشات پر صارف سے فیڈبیک طلب کریں اور ضروری ایڈجسٹمنٹ کریں۔

#### مطلوبہ وسائل

- فلائٹ اور ہوٹل بکنگ ڈیٹا بیس تک رسائی۔
- پیرس کے مقامات اور ریستوران کے بارے میں معلومات۔
- پچھلے تعاملات سے صارف کے فیڈبیک ڈیٹا۔

#### تجربہ اور خود تشخیص

ٹریول ایجنٹ اپنی کارکردگی کا جائزہ لینے اور ماضی کے تجربات سے سیکھنے کے لیے میٹا کوگنیشن کا استعمال کرتا ہے۔ مثال کے طور پر:

1. **صارف کے فیڈبیک کا تجزیہ**: ٹریول ایجنٹ صارف کے فیڈبیک کا جائزہ لیتا ہے تاکہ یہ معلوم کیا جا سکے کہ کون سی سفارشات کو پسند کیا گیا اور کون سی نہیں۔ یہ اپنی آئندہ تجاویز کو اسی کے مطابق ایڈجسٹ کرتا ہے۔
2. **موافقت**: اگر کسی صارف نے پہلے بھیڑ والی جگہوں کو ناپسند کرنے کا ذکر کیا ہے، تو ٹریول ایجنٹ آئندہ کے لیے مشہور سیاحتی مقامات کو مصروف اوقات میں تجویز کرنے سے گریز کرے گا۔
3. **غلطی کی اصلاح**: اگر ٹریول ایجنٹ نے ماضی میں کسی بکنگ میں غلطی کی، جیسے کہ ایک ہوٹل تجویز کرنا جو مکمل طور پر بک تھا، تو یہ آئندہ سفارشات دینے سے پہلے دستیابی کو زیادہ سختی سے چیک کرنے کا طریقہ سیکھتا ہے۔

#### عملی ڈویلپر مثال

یہاں ایک سادہ مثال ہے کہ ٹریول ایجنٹ کا کوڈ میٹا کوگنیشن کو شامل کرتے ہوئے کیسا نظر آ سکتا ہے:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Search for flights, hotels, and attractions based on preferences
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Analyze feedback and adjust future recommendations
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### میٹا کوگنیشن کیوں اہم ہے

- **خود تشخیص**: ایجنٹس اپنی کارکردگی کا تجزیہ کر سکتے ہیں اور بہتری کے لیے شعبوں کی نشاندہی کر سکتے ہیں۔
- **موافقت**: ایجنٹس فیڈبیک اور بدلتے حالات کی بنیاد پر حکمت عملیوں کو تبدیل کر سکتے ہیں۔
- **غلطی کی اصلاح**: ایجنٹس خود مختار طور پر غلطیوں کا پتہ لگا سکتے ہیں اور انہیں درست کر سکتے ہیں۔
- **وسائل کا انتظام**: ایجنٹس وسائل کے استعمال کو بہتر بنا سکتے ہیں، جیسے وقت اور کمپیوٹیشنل پاور۔

میٹا کوگنیشن کو شامل کر کے، ٹریول ایجنٹ زیادہ ذاتی نوعیت کی اور درست سفری سفارشات فراہم کر سکتا ہے، جس سے مجموعی صارف کا تجربہ بہتر ہوتا ہے۔

---

## 2. ایجنٹس میں منصوبہ بندی

منصوبہ بندی AI ایجنٹ کے رویے کا ایک اہم جزو ہے۔ اس میں موجودہ حالت، وسائل، اور ممکنہ رکاوٹوں کو مدنظر رکھتے ہوئے کسی مقصد کو حاصل کرنے کے لیے اقدامات کا خاکہ بنانا شامل ہے۔

### منصوبہ بندی کے عناصر

- **موجودہ کام**: کام کو واضح طور پر بیان کریں۔
- **کام مکمل کرنے کے مراحل**: کام کو قابل انتظام مراحل میں تقسیم کریں۔
- **مطلوبہ وسائل**: ضروری وسائل کی نشاندہی کریں۔
- **تجربہ**: منصوبہ بندی کو مطلع کرنے کے لیے ماضی کے تجربات کا استعمال کریں۔

**مثال**:
یہاں وہ مراحل ہیں جو ٹریول ایجنٹ کو صارف کی مؤثر طریقے سے سفر کی منصوبہ بندی میں مدد کرنے کے لیے اٹھانے کی ضرورت ہے:

### ٹریول ایجنٹ کے مراحل

1. **صارف کی ترجیحات جمع کریں**
   - صارف سے ان کے سفر کی تاریخوں، بجٹ، دلچسپیوں، اور کسی خاص ضروریات کے بارے میں تفصیلات طلب کریں۔
   - مثالیں: "آپ کب سفر کرنے کا ارادہ رکھتے ہیں؟" "آپ کا بجٹ کیا ہے؟" "آپ چھٹیوں میں کون سی سرگرمیاں پسند کرتے ہیں؟"

2. **معلومات حاصل کریں**
   - صارف کی ترجیحات کی بنیاد پر متعلقہ سفری آپشنز تلاش کریں۔
   - **فلائٹس**: صارف کے بجٹ اور ترجیحی سفر کی تاریخوں کے اندر دستیاب فلائٹس تلاش کریں۔
   - **رہائش**: صارف کی ترجیحات کے مطابق مقام، قیمت، اور سہولیات کے لحاظ سے ہوٹل یا کرائے کی جائیدادیں تلاش کریں۔
   - **مقامات اور ریستوران**: صارف کی دلچسپیوں کے مطابق مشہور مقامات، سرگرمیاں، اور کھانے کے اختیارات کی نشاندہی کریں۔

3. **سفارشات تیار کریں**
   - حاصل کردہ معلومات کو ذاتی نوعیت کے سفر نامے میں مرتب کریں۔
   - فلائٹ آپشنز، ہوٹل کی بکنگ، اور تجویز کردہ سرگرمیوں کی تفصیلات فراہم کریں، اس بات کو یقینی بناتے ہوئے کہ سفارشات صارف کی ترجیحات کے مطابق ہوں۔

4. **سفر نامہ صارف کو پیش کریں**
   - تجویز کردہ سفر نامہ صارف کے جائزے کے لیے شیئر کریں۔
   - مثال: "یہ پیرس کے سفر کے لیے ایک تجویز کردہ سفر نامہ ہے۔ اس میں فلائٹ کی تفصیلات، ہوٹل کی بکنگ، اور تجویز کردہ سرگرمیوں اور ریستورانوں کی فہرست شامل ہے۔ مجھے اپنی رائے بتائیں!"

5. **فیڈبیک جمع کریں**
   - تجویز کردہ سفر نامے پر صارف سے فیڈبیک طلب کریں۔
   - مثالیں: "کیا آپ کو فلائٹ آپشنز پسند ہیں؟" "کیا ہوٹل آپ کی ضروریات کے لیے موزوں ہے؟" "کیا کوئی سرگرمیاں ہیں جنہیں آپ شامل یا ہٹانا چاہتے ہیں؟"

6. **فیڈبیک کی بنیاد پر ایڈجسٹ کریں**
   - صارف کے فیڈبیک کی بنیاد پر سفر نامے میں ترمیم کریں۔
   - فلائٹ، رہائش، اور سرگرمی کی سفارشات کو صارف کی ترجیحات سے بہتر طور پر میل کرنے کے لیے ضروری تبدیلیاں کریں۔

7. **حتمی تصدیق**
   - صارف کو حتمی تصدیق کے لیے اپ ڈیٹ شدہ سفر نامہ پیش کریں۔
   - مثال: "میں نے آپ کے فیڈبیک کی بنیاد پر ایڈجسٹمنٹ کی ہیں۔ یہ اپ ڈیٹ شدہ سفر نامہ ہے۔ کیا سب کچھ آپ کو ٹھیک لگتا ہے؟"

8. **بکنگ اور تصدیق**
   - ایک بار جب صارف سفر نامے کی منظوری دے دے، فلائٹس، رہائش، اور کسی بھی پہلے سے منصوبہ بند سرگرمیوں کی بکنگ کے ساتھ آگے بڑھیں۔
   - صارف کو تصدیقی تفصیلات بھیجیں۔

9. **مسلسل مدد فراہم کریں**
   - سفر سے پہلے اور دوران صارف کی کسی بھی تبدیلی یا اضافی درخواستوں میں مدد کے لیے دستیاب رہیں۔
   - مثال: "اگر آپ کو اپنے سفر کے دوران مزید مدد کی ضرورت ہو، تو کسی بھی وقت مجھ سے رابطہ کریں!"

### مثال تعامل

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage within a booing request
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. اصلاحی RAG سسٹم

سب سے پہلے آئیے RAG ٹول اور پیشگی کانٹیکسٹ لوڈنگ کے فرق کو سمجھتے ہیں۔

![RAG بمقابلہ کانٹیکسٹ لوڈنگ](../../../translated_images/rag-vs-context.9eae588520c00921f531e4dc788992e8a7b69b6ff7c9eaa69fb9bc83ad243504.ur.png)

### ریٹریول-اگمینٹڈ جنریشن (RAG)

RAG ایک ریٹریول سسٹم کو جنریٹو ماڈل کے ساتھ جوڑتا ہے۔ جب کوئی سوال کیا جاتا ہے، تو ریٹریول سسٹم بیرونی ذریعہ سے متعلقہ دستاویزات یا ڈیٹا حاصل کرتا ہے، اور یہ حاصل کردہ معلومات جنریٹو ماڈل کے ان پٹ کو اگمینٹ کرنے کے لیے استعمال ہوتی ہیں۔ یہ ماڈل کو زیادہ درست اور سیاق و سباق کے لحاظ سے متعلقہ جوابات پیدا کرنے میں مدد دیتا ہے۔

RAG سسٹم میں، ایجنٹ علم کے ذخیرے سے متعلقہ معلومات حاصل کرتا ہے اور مناسب جوابات یا کارروائیاں پیدا کرنے کے لیے ان کا استعمال کرتا ہے۔

### اصلاحی RAG طریقہ

اصلاحی RAG طریقہ RAG تکنیکوں کا استعمال کرتے ہوئے غلطیوں کو درست کرنے اور AI ایجنٹس کی درستگی کو بہتر بنانے پر مرکوز ہے۔ اس میں شامل ہے:

1. **پرومپٹنگ تکنیک**: ایجنٹ کو متعلقہ معلومات حاصل کرنے میں رہنمائی کرنے کے لیے مخصوص پرومپٹس کا استعمال۔
2. **ٹول**: ایسے الگورتھمز اور میکانزم کو نافذ کرنا جو ایجنٹ کو حاصل کردہ معلومات کی مطابقت کا جائزہ لینے اور درست جوابات پیدا کرنے کے قابل بناتے ہیں۔
3. **تشخیص**: ایجنٹ کی کارکردگی کا مسلسل جائزہ لینا اور اس کی درستگی اور کارکردگی کو بہتر بنانے کے لیے ایڈجسٹمنٹ کرنا۔

#### مثال: سرچ ایجنٹ میں اصلاحی RAG

فرض کریں کہ ایک سرچ ایجنٹ ویب سے معلومات حاصل کرتا ہے تاکہ صارف کے سوالات کے جوابات دے سکے۔ اصلاحی RAG طریقہ شامل ہو سکتا ہے:

1. **پرومپٹنگ تکنیک**: صارف کے ان پٹ کی بنیاد پر سرچ سوالات تیار کرنا۔
2. **ٹول**: قدرتی زبان کی پروسیسنگ اور مشین لرننگ الگورتھمز کا استعمال کرتے ہوئے سرچ نتائج کو درجہ بندی اور فلٹر کرنا۔
3. **تشخیص**: صارف کے فیڈبیک کا تجزیہ کرتے ہوئے حاصل کردہ معلومات میں غلطیوں کی نشاندہی اور اصلاح کرنا۔

### ٹریول ایجنٹ میں اصلاحی RAG

اصلاحی RAG (ریٹریول-اگمینٹڈ جنریشن) AI کی معلومات حاصل کرنے اور پیدا کرنے کی صلاحیت کو بڑھاتا ہے جبکہ کسی بھی غلطیوں کو درست کرتا ہے۔ آئیے دیکھتے ہیں کہ ٹریول ایجنٹ اصلاحی RAG طریقہ استعمال کرتے ہوئے زیادہ درست اور متعلقہ سفری سفارشات کیسے فراہم کر سکتا ہے۔

اس میں شامل ہے:

- **پرومپٹنگ تکنیک:** ایجنٹ کو متعلقہ معلومات حاصل کرنے میں رہنمائی کرنے کے لیے مخصوص پرومپٹس کا استعمال۔
- **ٹول:** ایسے الگورتھمز اور میکانزم کو نافذ کرنا جو ایجنٹ کو حاصل کردہ معلومات کی مطابقت کا جائزہ لینے اور درست جوابات پیدا کرنے کے قابل بناتے ہیں۔
- **تشخیص:** ایجنٹ کی کارکردگی کا مسلسل جائزہ لینا اور اس کی
```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### پیشگی سیاق و سباق لوڈ کرنا

پیشگی سیاق و سباق لوڈ کرنے کا مطلب ہے کہ ماڈل میں کسی سوال کے پروسیسنگ سے پہلے متعلقہ معلومات یا پس منظر شامل کر دیا جائے۔ اس کا مطلب یہ ہے کہ ماڈل کے پاس شروع سے ہی یہ معلومات موجود ہوتی ہیں، جو اسے مزید معلومات حاصل کیے بغیر زیادہ بہتر جوابات دینے میں مدد دیتی ہیں۔

یہاں ایک سادہ مثال دی گئی ہے کہ سفر کے ایجنٹ کی ایپلیکیشن میں پیشگی سیاق و سباق لوڈ کیسے کیا جا سکتا ہے:

```python
class TravelAgent:
    def __init__(self):
        # Pre-load popular destinations and their information
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Fetch destination information from pre-loaded context
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Example usage
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### وضاحت

1. **ابتدائیہ (`__init__` method)**: `TravelAgent` کلاس ایک ڈکشنری لوڈ کرتی ہے جس میں مشہور مقامات جیسے پیرس، ٹوکیو، نیویارک، اور سڈنی کی معلومات شامل ہوتی ہیں۔ اس ڈکشنری میں ہر مقام کے بارے میں ملک، کرنسی، زبان، اور اہم مقامات کی تفصیلات شامل ہوتی ہیں۔

2. **معلومات حاصل کرنا (`get_destination_info` method)**: جب کوئی صارف کسی خاص مقام کے بارے میں پوچھتا ہے، تو `get_destination_info` میتھڈ اس مقام کی متعلقہ معلومات پہلے سے لوڈ شدہ ڈکشنری سے حاصل کرتا ہے۔

پیشگی سیاق و سباق لوڈ کرنے سے سفر کے ایجنٹ کی ایپلیکیشن صارف کے سوالات کا فوری جواب دے سکتی ہے، بغیر اس کے کہ یہ معلومات حقیقی وقت میں کسی بیرونی ذریعہ سے حاصل کی جائیں۔ یہ ایپلیکیشن کو زیادہ مؤثر اور تیز بناتا ہے۔

### مقصد کے ساتھ منصوبہ بندی کا آغاز اور پھر تکرار

کسی منصوبے کا آغاز ایک واضح مقصد کے ساتھ کرنا اس بات کو یقینی بناتا ہے کہ ہر قدم مطلوبہ نتائج کے قریب لے جائے۔ مقصد کو پہلے سے طے کرنے سے ماڈل کو ایک رہنما اصول ملتا ہے، جو پورے عمل کو زیادہ مؤثر اور مرکوز بناتا ہے۔

یہاں ایک مثال دی گئی ہے کہ سفر کے ایجنٹ کے لیے ایک مقصد کے ساتھ منصوبہ کیسے شروع کیا جا سکتا ہے:

### منظرنامہ

ایک سفر کا ایجنٹ کسی کلائنٹ کے لیے ایک حسب ضرورت چھٹی کا منصوبہ بنانا چاہتا ہے۔ مقصد یہ ہے کہ کلائنٹ کی ترجیحات اور بجٹ کے مطابق ایک ایسا سفر نامہ تیار کیا جائے جو ان کی تسلی کو زیادہ سے زیادہ کرے۔

### مراحل

1. کلائنٹ کی ترجیحات اور بجٹ کی وضاحت کریں۔
2. ان ترجیحات کی بنیاد پر ابتدائی منصوبہ بنائیں۔
3. منصوبے کو بہتر بنانے کے لیے تکرار کریں، کلائنٹ کی تسلی کو مدنظر رکھتے ہوئے۔

#### Python کوڈ

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Example usage
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### کوڈ کی وضاحت

1. **ابتدائیہ (`__init__` method)**: `TravelAgent` کلاس ممکنہ مقامات کی ایک فہرست کے ساتھ شروع ہوتی ہے، جن میں نام، لاگت، اور سرگرمی کی قسم جیسی خصوصیات شامل ہوتی ہیں۔

2. **منصوبہ بندی کا آغاز (`bootstrap_plan` method)**: یہ میتھڈ کلائنٹ کی ترجیحات اور بجٹ کی بنیاد پر ایک ابتدائی منصوبہ بناتا ہے۔ یہ مقامات کی فہرست میں سے ان کو منتخب کرتا ہے جو کلائنٹ کی ترجیحات سے میل کھاتے ہیں اور بجٹ میں فٹ ہوتے ہیں۔

3. **ترجیحات کا میل (`match_preferences` method)**: یہ میتھڈ چیک کرتا ہے کہ آیا کوئی مقام کلائنٹ کی ترجیحات سے میل کھاتا ہے۔

4. **منصوبے کی تکرار (`iterate_plan` method)**: یہ میتھڈ ابتدائی منصوبے کو بہتر بناتا ہے، ہر مقام کو ایک بہتر متبادل کے ساتھ تبدیل کرنے کی کوشش کرتا ہے، کلائنٹ کی ترجیحات اور بجٹ کو مدنظر رکھتے ہوئے۔

5. **لاگت کا حساب (`calculate_cost` method)**: یہ میتھڈ موجودہ منصوبے کی کل لاگت کا حساب لگاتا ہے، بشمول کسی ممکنہ نئے مقام کے۔

#### مثال کے استعمال

- **ابتدائی منصوبہ**: سفر کا ایجنٹ کلائنٹ کی ترجیحات (جیسے سیر و تفریح) اور $2000 کے بجٹ کی بنیاد پر ایک ابتدائی منصوبہ بناتا ہے۔
- **بہتر منصوبہ**: سفر کا ایجنٹ منصوبے کو بہتر بناتا ہے، کلائنٹ کی ترجیحات اور بجٹ کو مدنظر رکھتے ہوئے۔

ایک واضح مقصد کے ساتھ منصوبہ بندی کا آغاز اور تکرار کے ذریعے منصوبے کو بہتر بنانا سفر کے ایجنٹ کو کلائنٹ کے لیے ایک حسب ضرورت اور بہتر سفر نامہ تیار کرنے میں مدد دیتا ہے۔ یہ طریقہ کار اس بات کو یقینی بناتا ہے کہ منصوبہ شروع سے ہی کلائنٹ کی ترجیحات اور بجٹ کے مطابق ہو اور ہر تکرار کے ساتھ بہتر ہو۔

### LLM کا فائدہ اٹھانا: دوبارہ ترتیب دینا اور اسکورنگ

بڑے زبان کے ماڈلز (LLMs) کو دوبارہ ترتیب دینے اور اسکورنگ کے لیے استعمال کیا جا سکتا ہے تاکہ حاصل شدہ دستاویزات یا جوابات کی مطابقت اور معیار کا جائزہ لیا جا سکے۔ یہ کیسے کام کرتا ہے:

**حصول**: ابتدائی مرحلے میں سوال کے مطابق دستاویزات یا جوابات کی ایک فہرست حاصل کی جاتی ہے۔

**دوبارہ ترتیب دینا**: LLM ان دستاویزات کا جائزہ لیتا ہے اور ان کی مطابقت اور معیار کی بنیاد پر دوبارہ ترتیب دیتا ہے۔ اس سے یہ یقینی بنتا ہے کہ سب سے زیادہ متعلقہ اور معیاری معلومات پہلے پیش کی جائیں۔

**اسکورنگ**: LLM ہر دستاویز کو ایک اسکور دیتا ہے، جو اس کی مطابقت اور معیار کو ظاہر کرتا ہے۔ یہ صارف کے لیے بہترین جواب یا دستاویز منتخب کرنے میں مدد دیتا ہے۔

LLMs کا فائدہ اٹھا کر، نظام زیادہ درست اور سیاق و سباق سے متعلق معلومات فراہم کر سکتا ہے، جس سے صارف کا مجموعی تجربہ بہتر ہوتا ہے۔

یہاں ایک مثال دی گئی ہے کہ سفر کا ایجنٹ کس طرح LLM کا استعمال کرتے ہوئے صارف کی ترجیحات کی بنیاد پر سفر کے مقامات کو دوبارہ ترتیب دے سکتا ہے:

#### منظرنامہ - ترجیحات پر مبنی سفر

ایک سفر کا ایجنٹ کلائنٹ کی ترجیحات کی بنیاد پر بہترین سفر کے مقامات کی سفارش کرنا چاہتا ہے۔ LLM مقامات کو دوبارہ ترتیب دینے اور اسکور کرنے میں مدد کرے گا تاکہ سب سے زیادہ متعلقہ اختیارات پیش کیے جا سکیں۔

#### مراحل:

1. صارف کی ترجیحات جمع کریں۔
2. ممکنہ سفر کے مقامات کی فہرست حاصل کریں۔
3. LLM کا استعمال کرتے ہوئے مقامات کو دوبارہ ترتیب دیں اور اسکور کریں۔

Azure OpenAI Services کے استعمال کے لیے درج ذیل کوڈ کو اپ ڈیٹ کریں:

#### ضروریات

1. آپ کے پاس Azure سبسکرپشن ہونی چاہیے۔
2. Azure OpenAI ریسورس بنائیں اور اپنا API کلید حاصل کریں۔

#### Python کوڈ کی مثال

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Generate a prompt for the Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Define headers and payload for the request
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Call the Azure OpenAI API to get the re-ranked and scored destinations
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Extract and return the recommendations
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Example usage
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### کوڈ کی وضاحت - ترجیحی بکنگ

1. **ابتدائیہ**: `TravelAgent` کلاس ممکنہ سفر کے مقامات کی فہرست کے ساتھ شروع ہوتی ہے، جن میں نام اور تفصیل جیسی خصوصیات شامل ہوتی ہیں۔

2. **سفارشات حاصل کرنا (`get_recommendations` method)**: یہ میتھڈ Azure OpenAI سروس کے لیے صارف کی ترجیحات کی بنیاد پر ایک پرامپٹ تیار کرتا ہے اور API سے دوبارہ ترتیب دی گئی اور اسکور شدہ سفارشات حاصل کرتا ہے۔

3. **پرامپٹ تیار کرنا (`generate_prompt` method)**: یہ میتھڈ Azure OpenAI کے لیے ایک پرامپٹ تیار کرتا ہے، جس میں صارف کی ترجیحات اور مقامات کی فہرست شامل ہوتی ہے۔

4. **API کال**: `requests` لائبریری کا استعمال کرتے ہوئے Azure OpenAI API کو HTTP POST درخواست بھیجی جاتی ہے۔ جواب میں دوبارہ ترتیب دی گئی اور اسکور شدہ سفارشات شامل ہوتی ہیں۔

5. **مثال کے استعمال**: سفر کا ایجنٹ صارف کی ترجیحات (جیسے سیر و تفریح اور متنوع ثقافت) جمع کرتا ہے اور Azure OpenAI سروس کا استعمال کرتے ہوئے دوبارہ ترتیب دی گئی اور اسکور شدہ سفارشات حاصل کرتا ہے۔

اپنی اصل Azure OpenAI API کلید اور API کے اختتامی URL کو مناسب جگہ پر شامل کریں۔

LLM کا فائدہ اٹھا کر، سفر کا ایجنٹ زیادہ ذاتی اور متعلقہ سفر کی سفارشات فراہم کر سکتا ہے، جس سے کلائنٹ کا تجربہ بہتر ہوتا ہے۔

### RAG: پرامپٹنگ تکنیک بمقابلہ ٹول

ریٹریول-اگمینٹڈ جنریشن (RAG) کو پرامپٹنگ تکنیک اور ٹول دونوں کے طور پر استعمال کیا جا سکتا ہے۔ ان کے درمیان فرق کو سمجھنا آپ کو اپنے منصوبوں میں RAG کو مؤثر طریقے سے استعمال کرنے میں مدد دے سکتا ہے۔

#### RAG بطور پرامپٹنگ تکنیک

**یہ کیا ہے؟**

- پرامپٹنگ تکنیک کے طور پر، RAG مخصوص سوالات یا پرامپٹس تیار کرنے کے لیے استعمال ہوتا ہے تاکہ کسی بڑے ڈیٹا بیس سے متعلقہ معلومات حاصل کی جا سکیں۔ یہ معلومات پھر جوابات یا اعمال پیدا کرنے کے لیے استعمال ہوتی ہیں۔

**یہ کیسے کام کرتا ہے:**

1. **پرامپٹس تیار کریں**: صارف کے ان پٹ یا کام کی بنیاد پر اچھی طرح سے تشکیل شدہ پرامپٹس بنائیں۔
2. **معلومات حاصل کریں**: پرامپٹس کا استعمال کرتے ہوئے پہلے سے موجود علم کے ذخیرے سے متعلقہ ڈیٹا تلاش کریں۔
3. **جواب تیار کریں**: حاصل شدہ معلومات کو جنریٹو AI ماڈلز کے ساتھ جوڑ کر ایک جامع اور مربوط جواب تیار کریں۔

**سفر کے ایجنٹ میں مثال**:

- صارف کا ان پٹ: "میں پیرس میں عجائب گھروں کا دورہ کرنا چاہتا ہوں۔"
- پرامپٹ: "پیرس کے بہترین عجائب گھروں کو تلاش کریں۔"
- حاصل شدہ معلومات: لوور میوزیم، Musée d'Orsay وغیرہ کی تفصیلات۔
- تیار کردہ جواب: "یہاں پیرس کے کچھ بہترین عجائب گھر ہیں: لوور میوزیم، Musée d'Orsay، اور Centre Pompidou۔"

#### RAG بطور ٹول

**یہ کیا ہے؟**

- ایک ٹول کے طور پر، RAG ایک مربوط نظام ہے جو حصول اور جنریشن کے عمل کو خودکار بناتا ہے، جس سے ڈویلپرز کے لیے ہر سوال کے لیے دستی طور پر پرامپٹس تیار کیے بغیر پیچیدہ AI فعالیتوں کو نافذ کرنا آسان ہو جاتا ہے۔

**یہ کیسے کام کرتا ہے:**

1. **انضمام**: RAG کو AI ایجنٹ کی ساخت میں شامل کریں، تاکہ یہ خودکار طور پر حصول اور جنریشن کے کاموں کو سنبھال سکے۔
2. **خودکاری**: ٹول پورے عمل کو سنبھالتا ہے، صارف کے ان پٹ سے لے کر حتمی جواب تیار کرنے تک، بغیر ہر مرحلے کے لیے واضح پرامپٹس کی ضرورت کے۔
3. **موثر**: ایجنٹ کی کارکردگی کو بہتر بناتا ہے، حصول اور جنریشن کے عمل کو ہموار کرتا ہے، اور تیز اور زیادہ درست جوابات فراہم کرتا ہے۔

**سفر کے ایجنٹ میں مثال**:

- صارف کا ان پٹ: "میں پیرس میں عجائب گھروں کا دورہ کرنا چاہتا ہوں۔"
- RAG ٹول: خودکار طور پر عجائب گھروں کے بارے میں معلومات حاصل کرتا ہے اور جواب تیار کرتا ہے۔
- تیار کردہ جواب: "یہاں پیرس کے کچھ بہترین عجائب گھر ہیں: لوور میوزیم، Musée d'Orsay، اور Centre Pompidou۔"

### موازنہ

| پہلو                  | پرامپٹنگ تکنیک                                           | ٹول                                                   |
|-----------------------|----------------------------------------------------------|-------------------------------------------------------|
| **دستی بمقابلہ خودکار**| ہر سوال کے لیے پرامپٹس کی دستی تشکیل۔                     | حصول اور جنریشن کے لیے خودکار عمل۔                   |
| **کنٹرول**            | حصول کے عمل پر زیادہ کنٹرول فراہم کرتا ہے۔                | حصول اور جنریشن کو ہموار اور خودکار بناتا ہے۔        |
| **لچک**               | مخصوص ضروریات کے مطابق حسب ضرورت پرامپٹس کی اجازت دیتا ہے۔| بڑے پیمانے پر نفاذ کے لیے زیادہ مؤثر۔                |
| **پیچیدگی**           | پرامپٹس کی تشکیل اور ایڈجسٹمنٹ کی ضرورت ہوتی ہے۔          | AI ایجنٹ کی ساخت میں شامل کرنا آسان۔                |

### عملی مثالیں

**پرامپٹنگ تکنیک کی مثال:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**ٹول کی مثال:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### مطابقت کا جائزہ لینا

AI ایجنٹ کی کارکردگی کا ایک اہم پہلو مطابقت کا جائزہ لینا ہے۔ یہ یقینی بناتا ہے کہ ایجنٹ کے ذریعے حاصل کی گئی اور تیار کی گئی معلومات صارف کے لیے مناسب، درست، اور مفید ہیں۔ آئیے مطابقت کے جائزے کے لیے کلیدی تصورات اور تکنیکوں کا جائزہ لیتے ہیں۔

#### مطابقت کے جائزے میں کلیدی تصورات

1. **سیاق و سباق کی آگاہی**:
   - ایجنٹ کو صارف کے سوال کے سیاق و سباق کو سمجھنا چاہیے تاکہ متعلقہ معلومات حاصل اور تیار کی جا سکیں۔
   - مثال: اگر صارف "پیرس کے بہترین ریستوران" پوچھتا ہے، تو ایجنٹ کو صارف کی ترجیحات جیسے کھانے کی قسم اور بجٹ کو مدنظر رکھنا چاہیے۔

2. **درستگی**:
   - ایجنٹ کے فراہم کردہ معلومات کو حقائق پر مبنی اور تازہ ترین ہونا چاہیے۔
   - مثال: ایسے ریستوران کی سفارش کرنا جو کھلے ہوں اور اچھی ریویوز رکھتے ہوں۔

3. **صارف کا ارادہ**:
   - ایجنٹ کو صارف کے سوال کے پیچھے ارادے کو سمجھنا چاہیے تاکہ سب سے زیادہ متعلقہ معلومات فراہم کی جا سکیں۔
   - مثال: اگر صارف "بجٹ کے مطابق ہوٹل" پوچھتا ہے، تو ایجنٹ کو سستی اختیارات کو ترجیح دینی چاہیے۔

4. **فیڈبیک لوپ**:
   - صارف کے فیڈبیک کو مسلسل جمع کرنا اور تجزیہ کرنا ایجنٹ کو مطابقت کے جائزے کے عمل کو بہتر بنانے میں مدد دیتا ہے۔
   - مثال: پچھلی سفارشات پر صارف کی ریٹنگز اور فیڈبیک کو شامل کرنا۔

#### مطابقت کے جائزے کے لیے عملی تکنیکیں

1. **مطابقت اسکورنگ**:
   - ہر حاصل شدہ آئٹم کو ایک اسکور تفویض کریں جو صارف کے سوال اور ترجیحات سے اس کی مطابقت کو ظاہر کرے۔
   - مثال:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **فلٹرنگ اور رینکنگ**:
   - غیر متعلقہ آئٹمز کو فلٹر کریں اور باقی کو ان کے مطابقت اسکورز کی بنیاد پر رینک کریں۔
   - مثال:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Return top 10 relevant items
     ```

3. **قدرتی زبان کی پروسیسنگ (NLP)**:
   - صارف کے سوال کو سمجھنے اور متعلقہ معلومات حاصل کرنے کے لیے NLP تکنیکوں کا استعمال کریں۔
   - مثال:

     ```python
     def process_query(query):
         # Use NLP to extract key information from the user's query
         processed_query = nlp(query)
         return processed_query
     ```

4. **صارف کے فیڈبیک کا انضمام**:
   - فراہم کردہ سفارشات پر صارف کے فیڈبیک کو جمع کریں اور مستقبل کے جائزوں کو ایڈجسٹ کرنے کے لیے استعمال کریں۔
   - مثال:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### مثال: سفر کے ایجنٹ میں مطابقت کا جائزہ

یہاں ایک عملی مثال دی گئی ہے کہ سفر کا ایجنٹ سفر کی سفارشات کی مطابقت کا جائزہ کیسے لے سکتا ہے:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Return top 10 relevant items

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### ارادے کے ساتھ تلاش

ارادے کے ساتھ تلاش کا مطلب ہے کہ صارف کے سوال کے پیچھے موجود مقصد یا ہدف کو سمجھنا اور اس کے مطابق سب سے زیادہ متعلقہ اور مفید معلومات حاصل کرنا۔ یہ طریقہ صرف کلیدی الفاظ سے میل کھانے سے آگے بڑھ کر صارف کی اصل ضروریات اور سیاق و سباق کو سمجھنے پر توجہ دیتا ہے۔

#### ارادے کے ساتھ تلاش میں کلیدی تصورات

1. **صارف کے ارادے کو سمجھنا**:
   - صارف کے ارادے کو تین اہم اقسام میں تقسیم کیا جا سکتا ہے: معلوماتی، نیویگیشنل، اور لین دین۔
     - **معلوماتی ارادہ**: صارف کسی موضوع کے بارے میں معلومات حاصل کرنا چاہتا ہے (مثال: "پیرس کے بہترین عجائب گھر کون سے ہیں؟")۔
     - **نیویگیشنل ارادہ**: صارف کسی خاص ویب سائٹ یا صفحے پر جانا چاہتا ہے (مثال: "لوور میوزیم کی آفیشل ویب سائٹ")۔
     - **لین دین کا ارادہ**: صارف کوئی لین دین کرنا چاہتا ہے، جیسے فلائٹ بک کرنا یا خریداری کرنا (مثال: "پیرس کے لیے فلائٹ بک کریں")۔

2. **سیاق و سباق کی آگاہی**:
   - صارف کے سوال کے سیاق و سباق کا تجزیہ کرنا ارادے کی درست شناخت میں مدد دیتا ہے۔ اس میں پچھلی بات چیت، صارف کی ترجیحات، اور موجودہ سوال کی مخصوص تفصیلات شامل ہیں۔

3. **قدرتی زبان کی پروسیسنگ (NLP)**:
   - NLP تکنیکوں کا استعمال صارف کے قدرتی زبان کے سوالات کو سمجھنے اور ان کی تشریح کرنے کے لیے کیا جاتا ہے۔ اس میں ادارک کی شناخت، جذبات کا تجزیہ، اور سوال کی تجزیہ شامل ہیں۔

4. **ذاتی نوعیت**:
   - صارف کی تاریخ، ترجیحات، اور فیڈبیک کی بنیاد پر تلاش کے نتائج کو ذاتی بنانا معلومات کی مطابقت کو بڑھاتا ہے۔
#### عملی مثال: ٹریول ایجنٹ میں ارادے کے ساتھ تلاش کرنا

آئیے ٹریول ایجنٹ کو ایک مثال کے طور پر لیتے ہیں تاکہ دیکھ سکیں کہ ارادے کے ساتھ تلاش کیسے نافذ کی جا سکتی ہے۔

1. **صارف کی ترجیحات جمع کرنا**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **صارف کے ارادے کو سمجھنا**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **سیاق و سباق کی آگاہی**

   ```python
   def analyze_context(query, user_history):
       # Combine current query with user history to understand context
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **تلاش اور نتائج کو ذاتی بنانا**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Example search logic for informational intent
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Example search logic for navigational intent
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Example search logic for transactional intent
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Example personalization logic
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Return top 10 personalized results
   ```

5. **استعمال کی مثال**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. کوڈ کو ایک ٹول کے طور پر تیار کرنا

کوڈ تیار کرنے والے ایجنٹس AI ماڈلز کا استعمال کرتے ہوئے کوڈ لکھتے اور چلاتے ہیں، پیچیدہ مسائل حل کرتے ہیں اور کاموں کو خودکار بناتے ہیں۔

### کوڈ تیار کرنے والے ایجنٹس

کوڈ تیار کرنے والے ایجنٹس جنریٹو AI ماڈلز کا استعمال کرتے ہوئے کوڈ لکھتے اور چلاتے ہیں۔ یہ ایجنٹس پیچیدہ مسائل حل کر سکتے ہیں، کاموں کو خودکار بنا سکتے ہیں، اور مختلف پروگرامنگ زبانوں میں کوڈ تیار اور چلانے کے ذریعے قیمتی بصیرت فراہم کر سکتے ہیں۔

#### عملی اطلاقات

1. **خودکار کوڈ جنریشن**: مخصوص کاموں کے لیے کوڈ کے ٹکڑے تیار کریں، جیسے ڈیٹا تجزیہ، ویب اسکریپنگ، یا مشین لرننگ۔
2. **SQL بطور RAG**: ڈیٹا بیس سے ڈیٹا حاصل کرنے اور اس میں ترمیم کرنے کے لیے SQL کوئریز کا استعمال کریں۔
3. **مسائل کا حل**: مخصوص مسائل کو حل کرنے کے لیے کوڈ تیار کریں اور چلائیں، جیسے الگورتھم کو بہتر بنانا یا ڈیٹا کا تجزیہ کرنا۔

#### مثال: ڈیٹا تجزیہ کے لیے کوڈ تیار کرنے والا ایجنٹ

فرض کریں کہ آپ ایک کوڈ تیار کرنے والے ایجنٹ کو ڈیزائن کر رہے ہیں۔ یہ کیسے کام کر سکتا ہے:

1. **کام**: ڈیٹا سیٹ کا تجزیہ کریں تاکہ رجحانات اور نمونوں کی شناخت ہو سکے۔
2. **اقدامات**:
   - ڈیٹا سیٹ کو ڈیٹا تجزیہ کے ٹول میں لوڈ کریں۔
   - ڈیٹا کو فلٹر اور جمع کرنے کے لیے SQL کوئریز تیار کریں۔
   - کوئریز کو چلائیں اور نتائج حاصل کریں۔
   - نتائج کا استعمال کرتے ہوئے بصیرت اور تصورات تیار کریں۔
3. **ضروری وسائل**: ڈیٹا سیٹ تک رسائی، ڈیٹا تجزیہ کے ٹولز، اور SQL صلاحیتیں۔
4. **تجربہ**: ماضی کے تجزیہ کے نتائج کا استعمال کرتے ہوئے مستقبل کے تجزیوں کی درستگی اور مطابقت کو بہتر بنائیں۔

### مثال: ٹریول ایجنٹ کے لیے کوڈ تیار کرنے والا ایجنٹ

اس مثال میں، ہم ایک کوڈ تیار کرنے والے ایجنٹ، ٹریول ایجنٹ، کو ڈیزائن کریں گے تاکہ صارفین کو ان کے سفر کی منصوبہ بندی میں مدد فراہم کی جا سکے۔ یہ ایجنٹ جنریٹو AI کا استعمال کرتے ہوئے کوڈ تیار اور چلا سکتا ہے، جیسے سفر کے اختیارات حاصل کرنا، نتائج کو فلٹر کرنا، اور ایک سفر کا منصوبہ مرتب کرنا۔

#### کوڈ تیار کرنے والے ایجنٹ کا جائزہ

1. **صارف کی ترجیحات جمع کرنا**: صارف کی ان پٹ جمع کرتا ہے جیسے منزل، سفر کی تاریخیں، بجٹ، اور دلچسپیاں۔
2. **ڈیٹا حاصل کرنے کے لیے کوڈ تیار کرنا**: فلائٹس، ہوٹلوں، اور پرکشش مقامات کے بارے میں ڈیٹا حاصل کرنے کے لیے کوڈ کے ٹکڑے تیار کرتا ہے۔
3. **تیار کردہ کوڈ کو چلانا**: حقیقی وقت کی معلومات حاصل کرنے کے لیے تیار کردہ کوڈ چلاتا ہے۔
4. **سفر کا منصوبہ تیار کرنا**: حاصل کردہ ڈیٹا کو ذاتی سفر کے منصوبے میں مرتب کرتا ہے۔
5. **فیڈبیک کی بنیاد پر ایڈجسٹمنٹ**: صارف کی رائے حاصل کرتا ہے اور نتائج کو بہتر بنانے کے لیے ضرورت پڑنے پر کوڈ کو دوبارہ تیار کرتا ہے۔

#### مرحلہ وار نفاذ

1. **صارف کی ترجیحات جمع کرنا**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **ڈیٹا حاصل کرنے کے لیے کوڈ تیار کرنا**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Example: Generate code to search for flights based on user preferences
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Example: Generate code to search for hotels
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **تیار کردہ کوڈ کو چلانا**

   ```python
   def execute_code(code):
       # Execute the generated code using exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **سفر کا منصوبہ تیار کرنا**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **فیڈبیک کی بنیاد پر ایڈجسٹمنٹ**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Adjust preferences based on user feedback
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Regenerate and execute code with updated preferences
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### ماحولیاتی آگاہی اور استدلال کا فائدہ اٹھانا

ٹیبل کی اسکیمہ کی بنیاد پر استفسار جنریشن کے عمل کو بہتر بنایا جا سکتا ہے، ماحولیاتی آگاہی اور استدلال کا فائدہ اٹھاتے ہوئے۔

یہ کیسے کیا جا سکتا ہے اس کی ایک مثال یہاں ہے:

1. **اسکیمہ کو سمجھنا**: سسٹم ٹیبل کی اسکیمہ کو سمجھے گا اور اس معلومات کا استعمال استفسار جنریشن کو بنیاد فراہم کرنے کے لیے کرے گا۔
2. **فیڈبیک کی بنیاد پر ایڈجسٹمنٹ**: سسٹم فیڈبیک کی بنیاد پر صارف کی ترجیحات کو ایڈجسٹ کرے گا اور اسکیمہ میں کون سے فیلڈز کو اپ ڈیٹ کرنے کی ضرورت ہے اس پر غور کرے گا۔
3. **استفسار تیار کرنا اور چلانا**: سسٹم نئے ترجیحات کی بنیاد پر اپ ڈیٹ شدہ فلائٹ اور ہوٹل ڈیٹا حاصل کرنے کے لیے استفسار تیار کرے گا اور چلائے گا۔

یہاں ایک اپ ڈیٹ شدہ Python کوڈ کی مثال ہے جو ان تصورات کو شامل کرتی ہے:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Adjust preferences based on user feedback
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Reasoning based on schema to adjust other related preferences
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Custom logic to adjust preferences based on schema and feedback
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Generate code to fetch flight data based on updated preferences
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Generate code to fetch hotel data based on updated preferences
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Simulate execution of code and return mock data
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Generate itinerary based on flights, hotels, and attractions
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Example schema
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Example usage
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Regenerate and execute code with updated preferences
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### وضاحت - فیڈبیک کی بنیاد پر بکنگ

1. **اسکیمہ آگاہی**: `schema` ڈکشنری وضاحت کرتی ہے کہ فیڈبیک کی بنیاد پر ترجیحات کو کیسے ایڈجسٹ کیا جانا چاہیے۔ اس میں فیلڈز شامل ہیں جیسے `favorites` اور `avoid`، جن کے مطابق ایڈجسٹمنٹ کی جاتی ہے۔
2. **ترجیحات کو ایڈجسٹ کرنا (`adjust_based_on_feedback` method)**: یہ طریقہ صارف کی رائے اور اسکیمہ کی بنیاد پر ترجیحات کو ایڈجسٹ کرتا ہے۔
3. **ماحولیاتی بنیاد پر ایڈجسٹمنٹ (`adjust_based_on_environment` method)**: یہ طریقہ اسکیمہ اور فیڈبیک کی بنیاد پر ایڈجسٹمنٹ کو حسب ضرورت بناتا ہے۔
4. **استفسار تیار کرنا اور چلانا**: سسٹم ایڈجسٹ شدہ ترجیحات کی بنیاد پر اپ ڈیٹ شدہ فلائٹ اور ہوٹل ڈیٹا حاصل کرنے کے لیے کوڈ تیار کرتا ہے اور ان استفسارات کے نفاذ کی نقل کرتا ہے۔
5. **سفر کا منصوبہ تیار کرنا**: سسٹم نئے فلائٹ، ہوٹل، اور پرکشش مقامات کے ڈیٹا کی بنیاد پر اپ ڈیٹ شدہ سفر کا منصوبہ تیار کرتا ہے۔

سسٹم کو ماحولیاتی آگاہی فراہم کر کے اور اسکیمہ کی بنیاد پر استدلال کرتے ہوئے، یہ زیادہ درست اور متعلقہ استفسار تیار کر سکتا ہے، جس سے بہتر سفر کی تجاویز اور زیادہ ذاتی نوعیت کا صارف تجربہ حاصل ہوتا ہے۔

### SQL کو Retrieval-Augmented Generation (RAG) تکنیک کے طور پر استعمال کرنا

SQL (Structured Query Language) ڈیٹا بیس کے ساتھ تعامل کے لیے ایک طاقتور ٹول ہے۔ جب Retrieval-Augmented Generation (RAG) کے طریقہ کار کے حصے کے طور پر استعمال کیا جاتا ہے، SQL ڈیٹا بیس سے متعلقہ ڈیٹا حاصل کر سکتا ہے تاکہ AI ایجنٹس میں جوابات یا اعمال کو مطلع اور تیار کیا جا سکے۔ آئیے دیکھتے ہیں کہ SQL کو RAG تکنیک کے طور پر ٹریول ایجنٹ کے تناظر میں کیسے استعمال کیا جا سکتا ہے۔

#### کلیدی تصورات

1. **ڈیٹا بیس کے ساتھ تعامل**:
   - SQL کو ڈیٹا بیس سے استفسار کرنے، متعلقہ معلومات حاصل کرنے، اور ڈیٹا میں ترمیم کرنے کے لیے استعمال کیا جاتا ہے۔
   - مثال: فلائٹ کی تفصیلات، ہوٹل کی معلومات، اور پرکشش مقامات کو ٹریول ڈیٹا بیس سے حاصل کرنا۔

2. **RAG کے ساتھ انضمام**:
   - SQL کوئریز صارف کی ان پٹ اور ترجیحات کی بنیاد پر تیار کیے جاتے ہیں۔
   - حاصل کردہ ڈیٹا کو ذاتی تجاویز یا اعمال تیار کرنے کے لیے استعمال کیا جاتا ہے۔

3. **ڈائنامک استفسار جنریشن**:
   - AI ایجنٹ صارف کی ضروریات اور سیاق و سباق کی بنیاد پر ڈائنامک SQL کوئریز تیار کرتا ہے۔
   - مثال: بجٹ، تاریخوں، اور دلچسپیوں کی بنیاد پر نتائج کو فلٹر کرنے کے لیے SQL کوئریز کو حسب ضرورت بنانا۔

#### اطلاقات

- **خودکار کوڈ جنریشن**: مخصوص کاموں کے لیے کوڈ کے ٹکڑے تیار کریں۔
- **SQL بطور RAG**: ڈیٹا میں ترمیم کرنے کے لیے SQL کوئریز کا استعمال کریں۔
- **مسائل کا حل**: مسائل کو حل کرنے کے لیے کوڈ تیار کریں اور چلائیں۔

**مثال**:
ایک ڈیٹا تجزیہ ایجنٹ:

1. **کام**: ڈیٹا سیٹ کا تجزیہ کریں تاکہ رجحانات معلوم ہوں۔
2. **اقدامات**:
   - ڈیٹا سیٹ کو لوڈ کریں۔
   - ڈیٹا کو فلٹر کرنے کے لیے SQL کوئریز تیار کریں۔
   - کوئریز کو چلائیں اور نتائج حاصل کریں۔
   - بصیرت اور تصورات تیار کریں۔
3. **وسائل**: ڈیٹا سیٹ تک رسائی، SQL صلاحیتیں۔
4. **تجربہ**: ماضی کے نتائج کا استعمال کرتے ہوئے مستقبل کے تجزیوں کو بہتر بنائیں۔

#### عملی مثال: ٹریول ایجنٹ میں SQL کا استعمال

1. **صارف کی ترجیحات جمع کرنا**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **SQL کوئریز تیار کرنا**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **SQL کوئریز کو چلانا**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **تجاویز تیار کرنا**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### SQL کوئریز کی مثالیں

1. **فلائٹ کوئری**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **ہوٹل کوئری**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **پرکشش مقامات کوئری**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

SQL کو Retrieval-Augmented Generation (RAG) تکنیک کے حصے کے طور پر استعمال کرتے ہوئے، AI ایجنٹس جیسے ٹریول ایجنٹ متعلقہ ڈیٹا کو ڈائنامک طور پر حاصل اور استعمال کر سکتے ہیں تاکہ درست اور ذاتی تجاویز فراہم کی جا سکیں۔

### میٹا کوگنیشن کی مثال

میٹا کوگنیشن کے نفاذ کو ظاہر کرنے کے لیے، آئیے ایک سادہ ایجنٹ بنائیں جو *اپنے فیصلہ سازی کے عمل پر غور کرے* جبکہ ایک مسئلہ حل کر رہا ہو۔ اس مثال میں، ہم ایک سسٹم بنائیں گے جہاں ایجنٹ ہوٹل کے انتخاب کو بہتر بنانے کی کوشش کرتا ہے، لیکن پھر اپنے استدلال کا جائزہ لیتا ہے اور غلطیوں یا غیر موزوں انتخاب کرنے پر اپنی حکمت عملی کو ایڈجسٹ کرتا ہے۔

ہم اسے ایک بنیادی مثال کے ذریعے نقل کریں گے جہاں ایجنٹ قیمت اور معیار کے امتزاج کی بنیاد پر ہوٹل منتخب کرتا ہے، لیکن "غور" کرتا ہے اور اس کے مطابق ایڈجسٹ کرتا ہے۔

#### یہ میٹا کوگنیشن کو کیسے ظاہر کرتا ہے:

1. **ابتدائی فیصلہ**: ایجنٹ سب سے سستا ہوٹل منتخب کرے گا، بغیر معیار کے اثر کو سمجھے۔
2. **غور و فکر اور جائزہ**: ابتدائی انتخاب کے بعد، ایجنٹ چیک کرے گا کہ آیا ہوٹل "خراب" انتخاب ہے صارف کی رائے کی بنیاد پر۔ اگر اسے معلوم ہوتا ہے کہ ہوٹل کا معیار بہت کم تھا، تو وہ اپنے استدلال پر غور کرے گا۔
3. **حکمت عملی کو ایڈجسٹ کرنا**: ایجنٹ اپنے غور و فکر کی بنیاد پر اپنی حکمت عملی کو ایڈجسٹ کرے گا اور "سب سے سستا" سے "سب سے زیادہ معیار" پر منتقل ہو جائے گا، اس طرح مستقبل کے انتخاب میں اپنی فیصلہ سازی کے عمل کو بہتر بنائے گا۔

یہاں ایک مثال ہے:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Stores the hotels chosen previously
        self.corrected_choices = []  # Stores the corrected choices
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Available strategies

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Let's assume we have some user feedback that tells us whether the last choice was good or not
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Adjust strategy if the previous choice was unsatisfactory
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Simulate a list of hotels (price and quality)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Create an agent
agent = HotelRecommendationAgent()

# Step 1: The agent recommends a hotel using the "cheapest" strategy
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Step 2: The agent reflects on the choice and adjusts strategy if necessary
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Step 3: The agent recommends again, this time using the adjusted strategy
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### ایجنٹ کی میٹا کوگنیشن کی صلاحیتیں

اہم بات یہ ہے کہ ایجنٹ کی صلاحیت:
- اپنے پچھلے انتخاب اور فیصلہ سازی کے عمل کا جائزہ لینا۔
- اس غور و فکر کی بنیاد پر اپنی حکمت عملی کو ایڈجسٹ کرنا یعنی، میٹا کوگنیشن عمل میں۔

یہ میٹا کوگنیشن کی ایک سادہ شکل ہے جہاں سسٹم اندرونی فیڈبیک کی بنیاد پر اپنے استدلال کے عمل کو ایڈجسٹ کرنے کے قابل ہے۔

### نتیجہ

میٹا کوگنیشن ایک طاقتور ٹول ہے جو AI ایجنٹس کی صلاحیتوں کو نمایاں طور پر بڑھا سکتا ہے۔ میٹا کوگنیشن کے عمل کو شامل کر کے، آپ ایسے ایجنٹس ڈیزائن کر سکتے ہیں جو زیادہ ذہین، موافق، اور موثر ہوں۔ اضافی وسائل کا استعمال کریں تاکہ AI ایجنٹس میں میٹا کوگنیشن کی دلچسپ دنیا کو مزید دریافت کیا جا سکے۔

### میٹا کوگنیشن ڈیزائن پیٹرن کے بارے میں مزید سوالات ہیں؟

[Azure AI Foundry Discord](https://aka.ms/ai-agents/discord) میں شامل ہوں تاکہ دیگر سیکھنے والوں سے ملاقات کریں، آفس آورز میں شرکت کریں، اور اپنے AI ایجنٹس کے سوالات کے جوابات حاصل کریں۔

## پچھلا سبق

[ملٹی ایجنٹ ڈیزائن پیٹرن](../08-multi-agent/README.md)

## اگلا سبق

[پروڈکشن میں AI ایجنٹس](../10-ai-agents-production/README.md)

---

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا عدم درستگی ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے لیے ہم ذمہ دار نہیں ہیں۔