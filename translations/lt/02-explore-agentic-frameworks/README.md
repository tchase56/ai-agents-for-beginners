<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "a9631d0898fc3c6ecbb3a8a0da7aaba3",
  "translation_date": "2025-08-30T15:07:07+00:00",
  "source_file": "02-explore-agentic-frameworks/README.md",
  "language_code": "lt"
}
-->
[![Tyrinƒójame AI agent≈≥ sistemas](../../../translated_images/lesson-2-thumbnail.c65f44c93b8558df4d5d407e29970e654629e614f357444a9c27c80feb54c79d.lt.png)](https://youtu.be/ODwF-EZo_O8?si=1xoy_B9RNQfrYdF7)

> _(Spustelƒókite auk≈°ƒçiau esanƒçiƒÖ nuotraukƒÖ, kad per≈æi≈´rƒótumƒóte ≈°ios pamokos vaizdo ƒØra≈°ƒÖ)_

# Tyrinƒókite AI agent≈≥ sistemas

AI agent≈≥ sistemos yra programinƒós ƒØrangos platformos, skirtos supaprastinti AI agent≈≥ k≈´rimƒÖ, diegimƒÖ ir valdymƒÖ. ≈†ios sistemos suteikia k≈´rƒójams i≈° anksto sukurtus komponentus, abstrakcijas ir ƒØrankius, kurie palengvina sudƒóting≈≥ AI sistem≈≥ k≈´rimƒÖ.

≈†ios sistemos padeda k≈´rƒójams sutelkti dƒómesƒØ ƒØ unikalius j≈≥ program≈≥ aspektus, pateikdamos standartizuotus sprendimus da≈æniems AI agent≈≥ k≈´rimo i≈°≈°≈´kiams. Jos pagerina mastelio keitimƒÖ, prieinamumƒÖ ir efektyvumƒÖ kuriant AI sistemas.

## ƒÆvadas

≈†ioje pamokoje aptarsime:

- Kas yra AI agent≈≥ sistemos ir kƒÖ jos leid≈æia pasiekti k≈´rƒójams?
- Kaip komandos gali naudoti ≈°ias sistemas greitam prototip≈≥ k≈´rimui, iteracijai ir agent≈≥ galimybi≈≥ tobulinimui?
- Kokie yra skirtumai tarp Microsoft sukurt≈≥ sistem≈≥ ir ƒØranki≈≥?
- Ar galiu tiesiogiai integruoti savo esamus Azure ekosistemos ƒØrankius, ar man reikia atskir≈≥ sprendim≈≥?
- Kas yra Azure AI Agents paslauga ir kaip ji gali man padƒóti?

## Mokymosi tikslai

≈†ios pamokos tikslai yra padƒóti jums suprasti:

- AI agent≈≥ sistem≈≥ vaidmenƒØ AI k≈´rime.
- Kaip pasinaudoti AI agent≈≥ sistemomis kuriant intelektualius agentus.
- Pagrindines galimybes, kurias suteikia AI agent≈≥ sistemos.
- Skirtumus tarp AutoGen, Semantic Kernel ir Azure AI Agent Service.

## Kas yra AI agent≈≥ sistemos ir kƒÖ jos leid≈æia k≈´rƒójams daryti?

Tradicinƒós AI sistemos gali padƒóti integruoti AI ƒØ j≈´s≈≥ programas ir pagerinti jas ≈°iais b≈´dais:

- **Personalizacija**: AI gali analizuoti naudotoj≈≥ elgsenƒÖ ir pageidavimus, kad pateikt≈≥ suasmenintas rekomendacijas, turinƒØ ir patirtis.  
Pavyzdys: Transliacijos paslaugos, tokios kaip Netflix, naudoja AI, kad pasi≈´lyt≈≥ filmus ir laidas pagal per≈æi≈´r≈≥ istorijƒÖ, taip didindamos naudotoj≈≥ ƒØsitraukimƒÖ ir pasitenkinimƒÖ.
- **Automatizacija ir efektyvumas**: AI gali automatizuoti pasikartojanƒçias u≈æduotis, optimizuoti darbo eigas ir pagerinti operacinƒØ efektyvumƒÖ.  
Pavyzdys: Klient≈≥ aptarnavimo programos naudoja AI valdomus pokalbi≈≥ robotus, kad atsakyt≈≥ ƒØ da≈æniausiai u≈æduodamus klausimus, suma≈æindamos atsakymo laikƒÖ ir leisdamos ≈æmonƒóms sprƒôsti sudƒótingesnes problemas.
- **Patobulinta naudotojo patirtis**: AI gali pagerinti bendrƒÖ naudotojo patirtƒØ, suteikdama intelektualias funkcijas, tokias kaip balso atpa≈æinimas, nat≈´ralios kalbos apdorojimas ir prognozuojantis tekstas.  
Pavyzdys: Virtual≈´s asistentai, tokie kaip Siri ir Google Assistant, naudoja AI, kad suprast≈≥ ir atsakyt≈≥ ƒØ balso komandas, palengvindami naudotoj≈≥ sƒÖveikƒÖ su ƒØrenginiais.

### Skamba puikiai, tiesa? Tai kodƒól mums reikia AI agent≈≥ sistem≈≥?

AI agent≈≥ sistemos yra daugiau nei tik AI sistemos. Jos skirtos kurti intelektualius agentus, kurie gali sƒÖveikauti su naudotojais, kitais agentais ir aplinka, siekdami konkreƒçi≈≥ tiksl≈≥. ≈†ie agentai gali demonstruoti autonominƒØ elgesƒØ, priimti sprendimus ir prisitaikyti prie besikeiƒçianƒçi≈≥ sƒÖlyg≈≥. Pa≈ævelkime ƒØ pagrindines galimybes, kurias suteikia AI agent≈≥ sistemos:

- **Agent≈≥ bendradarbiavimas ir koordinavimas**: Leid≈æia kurti kelis AI agentus, kurie gali dirbti kartu, bendrauti ir koordinuoti veiksmus, kad i≈°sprƒôst≈≥ sudƒótingas u≈æduotis.
- **U≈æduoƒçi≈≥ automatizavimas ir valdymas**: Suteikia mechanizmus daugiapakopi≈≥ darbo eig≈≥ automatizavimui, u≈æduoƒçi≈≥ delegavimui ir dinami≈°kam u≈æduoƒçi≈≥ valdymui tarp agent≈≥.
- **Konteksto supratimas ir prisitaikymas**: Apr≈´pina agentus gebƒójimu suprasti kontekstƒÖ, prisitaikyti prie besikeiƒçianƒçios aplinkos ir priimti sprendimus remiantis realaus laiko informacija.

Apibendrinant, agentai leid≈æia pasiekti daugiau, perkelti automatizavimƒÖ ƒØ kitƒÖ lygƒØ, kurti intelektualesnes sistemas, kurios gali prisitaikyti ir mokytis i≈° savo aplinkos.

## Kaip greitai kurti prototipus, iteruoti ir tobulinti agent≈≥ galimybes?

Tai sparƒçiai besikeiƒçianti sritis, taƒçiau yra keletas bendr≈≥ dalyk≈≥ daugelyje AI agent≈≥ sistem≈≥, kurie gali padƒóti greitai kurti prototipus ir iteruoti, b≈´tent modulini≈≥ komponent≈≥ naudojimas, bendradarbiavimo ƒØrankiai ir mokymasis realiuoju laiku. Pa≈ævelkime ƒØ juos:

- **Naudokite modulinius komponentus**: AI SDK si≈´lo i≈° anksto sukurtus komponentus, tokius kaip AI ir atminties jungtys, funkcij≈≥ kvietimas naudojant nat≈´raliƒÖ kalbƒÖ ar kodo papildinius, ≈°ablonus ir kt.
- **Pasinaudokite bendradarbiavimo ƒØrankiais**: Kurkite agentus su konkreƒçiais vaidmenimis ir u≈æduotimis, leid≈æianƒçiais i≈°bandyti ir tobulinti bendradarbiavimo darbo eigas.
- **Mokykitƒós realiuoju laiku**: ƒÆgyvendinkite grƒØ≈ætamojo ry≈°io ciklus, kuriuose agentai mokosi i≈° sƒÖveik≈≥ ir dinami≈°kai koreguoja savo elgesƒØ.

### Naudokite modulinius komponentus

Tokie SDK kaip Microsoft Semantic Kernel ir LangChain si≈´lo i≈° anksto sukurtus komponentus, tokius kaip AI jungtys, ≈°ablonai ir atminties valdymas.

**Kaip komandos gali tai naudoti**: Komandos gali greitai surinkti ≈°iuos komponentus, kad sukurt≈≥ veikiantƒØ prototipƒÖ, nepradƒódamos nuo nulio, taip leid≈æiant greitai eksperimentuoti ir iteruoti.

**Kaip tai veikia praktikoje**: Galite naudoti i≈° anksto sukurtƒÖ analizatori≈≥, kad i≈°gautumƒóte informacijƒÖ i≈° naudotojo ƒØvesties, atminties modulƒØ duomenims saugoti ir atkurti, bei ≈°ablon≈≥ generatori≈≥ sƒÖveikai su naudotojais, viskƒÖ tai padarydami be poreikio kurti ≈°iuos komponentus nuo nulio.

**Kodo pavyzdys**. Pa≈ævelkime ƒØ pavyzd≈æius, kaip galite naudoti i≈° anksto sukurtƒÖ AI jungtƒØ su Semantic Kernel Python ir .Net, kuris naudoja automatinƒØ funkcij≈≥ kvietimƒÖ, kad modelis atsakyt≈≥ ƒØ naudotojo ƒØvestƒØ:

``` python
# Semantic Kernel Python Example

import asyncio
from typing import Annotated

from semantic_kernel.connectors.ai import FunctionChoiceBehavior
from semantic_kernel.connectors.ai.open_ai import AzureChatCompletion, AzureChatPromptExecutionSettings
from semantic_kernel.contents import ChatHistory
from semantic_kernel.functions import kernel_function
from semantic_kernel.kernel import Kernel

# Define a ChatHistory object to hold the conversation's context
chat_history = ChatHistory()
chat_history.add_user_message("I'd like to go to New York on January 1, 2025")


# Define a sample plugin that contains the function to book travel
class BookTravelPlugin:
    """A Sample Book Travel Plugin"""

    @kernel_function(name="book_flight", description="Book travel given location and date")
    async def book_flight(
        self, date: Annotated[str, "The date of travel"], location: Annotated[str, "The location to travel to"]
    ) -> str:
        return f"Travel was booked to {location} on {date}"

# Create the Kernel
kernel = Kernel()

# Add the sample plugin to the Kernel object
kernel.add_plugin(BookTravelPlugin(), plugin_name="book_travel")

# Define the Azure OpenAI AI Connector
chat_service = AzureChatCompletion(
    deployment_name="YOUR_DEPLOYMENT_NAME", 
    api_key="YOUR_API_KEY", 
    endpoint="https://<your-resource>.azure.openai.com/",
)

# Define the request settings to configure the model with auto-function calling
request_settings = AzureChatPromptExecutionSettings(function_choice_behavior=FunctionChoiceBehavior.Auto())


async def main():
    # Make the request to the model for the given chat history and request settings
    # The Kernel contains the sample that the model will request to invoke
    response = await chat_service.get_chat_message_content(
        chat_history=chat_history, settings=request_settings, kernel=kernel
    )
    assert response is not None

    """
    Note: In the auto function calling process, the model determines it can invoke the 
    `BookTravelPlugin` using the `book_flight` function, supplying the necessary arguments. 
    
    For example:

    "tool_calls": [
        {
            "id": "call_abc123",
            "type": "function",
            "function": {
                "name": "BookTravelPlugin-book_flight",
                "arguments": "{'location': 'New York', 'date': '2025-01-01'}"
            }
        }
    ]

    Since the location and date arguments are required (as defined by the kernel function), if the 
    model lacks either, it will prompt the user to provide them. For instance:

    User: Book me a flight to New York.
    Model: Sure, I'd love to help you book a flight. Could you please specify the date?
    User: I want to travel on January 1, 2025.
    Model: Your flight to New York on January 1, 2025, has been successfully booked. Safe travels!
    """

    print(f"`{response}`")
    # Example AI Model Response: `Your flight to New York on January 1, 2025, has been successfully booked. Safe travels! ‚úàÔ∏èüóΩ`

    # Add the model's response to our chat history context
    chat_history.add_assistant_message(response.content)


if __name__ == "__main__":
    asyncio.run(main())
```  
```csharp
// Semantic Kernel C# example

using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using System.ComponentModel;
using Microsoft.SemanticKernel.Connectors.AzureOpenAI;

ChatHistory chatHistory = [];
chatHistory.AddUserMessage("I'd like to go to New York on January 1, 2025");

var kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddAzureOpenAIChatCompletion(
    deploymentName: "NAME_OF_YOUR_DEPLOYMENT",
    apiKey: "YOUR_API_KEY",
    endpoint: "YOUR_AZURE_ENDPOINT"
);
kernelBuilder.Plugins.AddFromType<BookTravelPlugin>("BookTravel"); 
var kernel = kernelBuilder.Build();

var settings = new AzureOpenAIPromptExecutionSettings()
{
    FunctionChoiceBehavior = FunctionChoiceBehavior.Auto()
};

var chatCompletion = kernel.GetRequiredService<IChatCompletionService>();

var response = await chatCompletion.GetChatMessageContentAsync(chatHistory, settings, kernel);

/*
Behind the scenes, the model recognizes the tool to call, what arguments it already has (location) and (date)
{

"tool_calls": [
    {
        "id": "call_abc123",
        "type": "function",
        "function": {
            "name": "BookTravelPlugin-book_flight",
            "arguments": "{'location': 'New York', 'date': '2025-01-01'}"
        }
    }
]
*/

Console.WriteLine(response.Content);
chatHistory.AddMessage(response!.Role, response!.Content!);

// Example AI Model Response: Your flight to New York on January 1, 2025, has been successfully booked. Safe travels! ‚úàÔ∏èüóΩ

// Define a plugin that contains the function to book travel
public class BookTravelPlugin
{
    [KernelFunction("book_flight")]
    [Description("Book travel given location and date")]
    public async Task<string> BookFlight(DateTime date, string location)
    {
        return await Task.FromResult( $"Travel was booked to {location} on {date}");
    }
}
```  

≈†iame pavyzdyje matote, kaip galite pasinaudoti i≈° anksto sukurtu analizatoriumi, kad i≈°gautumƒóte pagrindinƒô informacijƒÖ i≈° naudotojo ƒØvesties, pvz., skryd≈æio u≈æsakymo u≈æklausos kilmƒô, paskirties vietƒÖ ir datƒÖ. ≈†is modulinis po≈æi≈´ris leid≈æia sutelkti dƒómesƒØ ƒØ auk≈°to lygio logikƒÖ.

### Pasinaudokite bendradarbiavimo ƒØrankiais

Tokios sistemos kaip CrewAI, Microsoft AutoGen ir Semantic Kernel palengvina keli≈≥ agent≈≥ k≈´rimƒÖ, kurie gali dirbti kartu.

**Kaip komandos gali tai naudoti**: Komandos gali kurti agentus su konkreƒçiais vaidmenimis ir u≈æduotimis, leid≈æianƒçiais i≈°bandyti ir tobulinti bendradarbiavimo darbo eigas bei pagerinti bendrƒÖ sistemos efektyvumƒÖ.

**Kaip tai veikia praktikoje**: Galite sukurti agent≈≥ komandƒÖ, kur kiekvienas agentas turi specializuotƒÖ funkcijƒÖ, pvz., duomen≈≥ gavimƒÖ, analizƒô ar sprendim≈≥ priƒómimƒÖ. ≈†ie agentai gali bendrauti ir dalintis informacija, kad pasiekt≈≥ bendrƒÖ tikslƒÖ, pvz., atsakyt≈≥ ƒØ naudotojo u≈æklausƒÖ ar atlikt≈≥ u≈æduotƒØ.

**Kodo pavyzdys (AutoGen)**:

```python
# creating agents, then create a round robin schedule where they can work together, in this case in order

# Data Retrieval Agent
# Data Analysis Agent
# Decision Making Agent

agent_retrieve = AssistantAgent(
    name="dataretrieval",
    model_client=model_client,
    tools=[retrieve_tool],
    system_message="Use tools to solve tasks."
)

agent_analyze = AssistantAgent(
    name="dataanalysis",
    model_client=model_client,
    tools=[analyze_tool],
    system_message="Use tools to solve tasks."
)

# conversation ends when user says "APPROVE"
termination = TextMentionTermination("APPROVE")

user_proxy = UserProxyAgent("user_proxy", input_func=input)

team = RoundRobinGroupChat([agent_retrieve, agent_analyze, user_proxy], termination_condition=termination)

stream = team.run_stream(task="Analyze data", max_turns=10)
# Use asyncio.run(...) when running in a script.
await Console(stream)
```  

≈†iame pavyzdyje matote, kaip galite sukurti u≈æduotƒØ, kurioje dalyvauja keli agentai, dirbantys kartu analizuoti duomenis. Kiekvienas agentas atlieka konkreƒçiƒÖ funkcijƒÖ, o u≈æduotis vykdoma koordinuojant agentus, kad b≈´t≈≥ pasiektas norimas rezultatas. Sukurdami specializuotus agentus su konkreƒçiais vaidmenimis, galite pagerinti u≈æduoƒçi≈≥ efektyvumƒÖ ir na≈°umƒÖ.

### Mokykitƒós realiuoju laiku

Pa≈æangios sistemos suteikia galimybes realiuoju laiku suprasti kontekstƒÖ ir prisitaikyti.

**Kaip komandos gali tai naudoti**: Komandos gali ƒØgyvendinti grƒØ≈ætamojo ry≈°io ciklus, kuriuose agentai mokosi i≈° sƒÖveik≈≥ ir dinami≈°kai koreguoja savo elgesƒØ, taip u≈ætikrindami nuolatinƒØ tobulƒójimƒÖ ir galimybi≈≥ plƒótrƒÖ.

**Kaip tai veikia praktikoje**: Agentai gali analizuoti naudotoj≈≥ atsiliepimus, aplinkos duomenis ir u≈æduoƒçi≈≥ rezultatus, kad atnaujint≈≥ savo ≈æini≈≥ bazƒô, koreguot≈≥ sprendim≈≥ priƒómimo algoritmus ir pagerint≈≥ na≈°umƒÖ laikui bƒógant. ≈†is iteracinis mokymosi procesas leid≈æia agentams prisitaikyti prie besikeiƒçianƒçi≈≥ sƒÖlyg≈≥ ir naudotoj≈≥ pageidavim≈≥, didinant bendrƒÖ sistemos efektyvumƒÖ.

## Kokie yra skirtumai tarp AutoGen, Semantic Kernel ir Azure AI Agent Service?

Yra daug b≈´d≈≥ palyginti ≈°ias sistemas, taƒçiau pa≈ævelkime ƒØ pagrindinius skirtumus j≈≥ dizaino, galimybi≈≥ ir tikslini≈≥ naudojimo atvej≈≥ at≈ævilgiu:

## AutoGen

AutoGen yra atvirojo kodo sistema, sukurta Microsoft Research AI Frontiers Lab. Ji orientuota ƒØ ƒØvyki≈≥ valdomas, paskirstytas *agentines* programas, leid≈æianƒçias naudoti kelis LLM, SLM, ƒØrankius ir pa≈æangius keli≈≥ agent≈≥ dizaino modelius.

AutoGen yra pagrƒØsta agent≈≥ koncepcija, kurie yra autonominiai subjektai, galintys suvokti savo aplinkƒÖ, priimti sprendimus ir imtis veiksm≈≥, siekdami konkreƒçi≈≥ tiksl≈≥. Agentai bendrauja per asinchroninius prane≈°imus, leid≈æianƒçius jiems dirbti nepriklausomai ir lygiagreƒçiai, taip didinant sistemos mastelƒØ ir atsakƒÖ.
Tai yra pagrindai apie Semantic Kernel sistemƒÖ, o kaip dƒól Agent Framework?

## Azure AI Agent Service

Azure AI Agent Service yra naujesnƒó funkcija, pristatyta Microsoft Ignite 2024 renginyje. Ji leid≈æia kurti ir diegti AI agentus naudojant lankstesnius modelius, tokius kaip tiesioginis ry≈°ys su atvirojo kodo LLM, pvz., Llama 3, Mistral ir Cohere.

Azure AI Agent Service si≈´lo stipresnius ƒØmonƒós saugumo mechanizmus ir duomen≈≥ saugojimo metodus, todƒól jis tinkamas naudoti ƒØmoni≈≥ programose.

≈†i paslauga veikia i≈° karto su daugiagentƒómis orkestravimo sistemomis, tokiomis kaip AutoGen ir Semantic Kernel.

≈†iuo metu paslauga yra vie≈°ojoje per≈æi≈´roje ir palaiko Python bei C# kalbas agent≈≥ k≈´rimui.

Naudodami Semantic Kernel Python, galime sukurti Azure AI Agent su vartotojo apibrƒó≈ætu ƒØskiepiu:

```python
import asyncio
from typing import Annotated

from azure.identity.aio import DefaultAzureCredential

from semantic_kernel.agents import AzureAIAgent, AzureAIAgentSettings, AzureAIAgentThread
from semantic_kernel.contents import ChatMessageContent
from semantic_kernel.contents import AuthorRole
from semantic_kernel.functions import kernel_function


# Define a sample plugin for the sample
class MenuPlugin:
    """A sample Menu Plugin used for the concept sample."""

    @kernel_function(description="Provides a list of specials from the menu.")
    def get_specials(self) -> Annotated[str, "Returns the specials from the menu."]:
        return """
        Special Soup: Clam Chowder
        Special Salad: Cobb Salad
        Special Drink: Chai Tea
        """

    @kernel_function(description="Provides the price of the requested menu item.")
    def get_item_price(
        self, menu_item: Annotated[str, "The name of the menu item."]
    ) -> Annotated[str, "Returns the price of the menu item."]:
        return "$9.99"


async def main() -> None:
    ai_agent_settings = AzureAIAgentSettings.create()

    async with (
        DefaultAzureCredential() as creds,
        AzureAIAgent.create_client(
            credential=creds,
            conn_str=ai_agent_settings.project_connection_string.get_secret_value(),
        ) as client,
    ):
        # Create agent definition
        agent_definition = await client.agents.create_agent(
            model=ai_agent_settings.model_deployment_name,
            name="Host",
            instructions="Answer questions about the menu.",
        )

        # Create the AzureAI Agent using the defined client and agent definition
        agent = AzureAIAgent(
            client=client,
            definition=agent_definition,
            plugins=[MenuPlugin()],
        )

        # Create a thread to hold the conversation
        # If no thread is provided, a new thread will be
        # created and returned with the initial response
        thread: AzureAIAgentThread | None = None

        user_inputs = [
            "Hello",
            "What is the special soup?",
            "How much does that cost?",
            "Thank you",
        ]

        try:
            for user_input in user_inputs:
                print(f"# User: '{user_input}'")
                # Invoke the agent for the specified thread
                response = await agent.get_response(
                    messages=user_input,
                    thread_id=thread,
                )
                print(f"# {response.name}: {response.content}")
                thread = response.thread
        finally:
            await thread.delete() if thread else None
            await client.agents.delete_agent(agent.id)


if __name__ == "__main__":
    asyncio.run(main())
```

### Pagrindinƒós sƒÖvokos

Azure AI Agent Service turi ≈°ias pagrindines sƒÖvokas:

- **Agentas**. Azure AI Agent Service integruojasi su Azure AI Foundry. AI Foundry viduje AI agentas veikia kaip ‚Äûprotinga‚Äú mikro paslauga, kuri gali atsakyti ƒØ klausimus (RAG), atlikti veiksmus arba visi≈°kai automatizuoti darbo eigas. Tai pasiekiama derinant generatyvini≈≥ AI modeli≈≥ galiƒÖ su ƒØrankiais, leid≈æianƒçiais pasiekti ir sƒÖveikauti su realaus pasaulio duomen≈≥ ≈°altiniais. ≈†tai agento pavyzdys:

    ```python
    agent = project_client.agents.create_agent(
        model="gpt-4o-mini",
        name="my-agent",
        instructions="You are helpful agent",
        tools=code_interpreter.definitions,
        tool_resources=code_interpreter.resources,
    )
    ```

    ≈†iame pavyzdyje agentas sukuriamas su modeliu `gpt-4o-mini`, pavadinimu `my-agent` ir instrukcijomis `You are helpful agent`. Agentas apr≈´pintas ƒØrankiais ir i≈°tekliais, kad galƒót≈≥ atlikti kodo interpretavimo u≈æduotis.

- **Gija ir ≈æinutƒós**. Gija yra dar viena svarbi sƒÖvoka. Ji atspindi pokalbƒØ arba sƒÖveikƒÖ tarp agento ir vartotojo. Gijos gali b≈´ti naudojamos pokalbio eigai stebƒóti, konteksto informacijai saugoti ir sƒÖveikos b≈´senai valdyti. ≈†tai gijos pavyzdys:

    ```python
    thread = project_client.agents.create_thread()
    message = project_client.agents.create_message(
        thread_id=thread.id,
        role="user",
        content="Could you please create a bar chart for the operating profit using the following data and provide the file to me? Company A: $1.2 million, Company B: $2.5 million, Company C: $3.0 million, Company D: $1.8 million",
    )
    
    # Ask the agent to perform work on the thread
    run = project_client.agents.create_and_process_run(thread_id=thread.id, agent_id=agent.id)
    
    # Fetch and log all messages to see the agent's response
    messages = project_client.agents.list_messages(thread_id=thread.id)
    print(f"Messages: {messages}")
    ```

    Ankstesniame kode sukuriama gija. Po to ƒØ gijƒÖ siunƒçiama ≈æinutƒó. I≈°kvietus `create_and_process_run`, agentas pra≈°omas atlikti darbƒÖ gijoje. Galiausiai ≈æinutƒós yra gaunamos ir registruojamos, kad b≈´t≈≥ matomas agento atsakas. ≈Ωinutƒós rodo pokalbio eigƒÖ tarp vartotojo ir agento. Taip pat svarbu suprasti, kad ≈æinutƒós gali b≈´ti ƒØvairi≈≥ tip≈≥, pvz., tekstas, vaizdas ar failas, tai yra agento darbo rezultatas, pavyzd≈æiui, vaizdas arba teksto atsakas. Kaip k≈´rƒójas, galite naudoti ≈°iƒÖ informacijƒÖ tolesniam atsako apdorojimui arba pateikimui vartotojui.

- **Integracija su kitomis AI sistemomis**. Azure AI Agent Service gali sƒÖveikauti su kitomis sistemomis, tokiomis kaip AutoGen ir Semantic Kernel, tai rei≈°kia, kad galite sukurti dalƒØ savo programos vienoje i≈° ≈°i≈≥ sistem≈≥, o, pavyzd≈æiui, naudoti Agent Service kaip orkestratori≈≥ arba viskƒÖ kurti Agent Service.

**Naudojimo atvejai**: Azure AI Agent Service yra skirtas ƒØmoni≈≥ programoms, kurioms reikalingas saugus, mastelio keiƒçiamas ir lankstus AI agent≈≥ diegimas.

## Kuo skiriasi ≈°ios sistemos?

Atrodo, kad ≈°ios sistemos turi daug bendro, taƒçiau yra keletas esmini≈≥ skirtum≈≥, susijusi≈≥ su j≈≥ dizainu, galimybƒómis ir tiksliniais naudojimo atvejais:

- **AutoGen**: Tai eksperimentinƒó sistema, orientuota ƒØ pa≈æangius daugiagentƒós sistemos tyrimus. Tai geriausia vieta eksperimentuoti ir kurti sudƒótingas daugiagentƒós sistemas.
- **Semantic Kernel**: Tai gamybai paruo≈°ta agent≈≥ biblioteka, skirta kurti ƒØmoni≈≥ agentines programas. Ji orientuota ƒØ ƒØvyki≈≥ valdomas, paskirstytas agentines programas, leid≈æianƒçias naudoti kelis LLM ir SLM, ƒØrankius bei vieno/daugiagentƒós dizaino modelius.
- **Azure AI Agent Service**: Tai platforma ir diegimo paslauga Azure Foundry agentams. Ji si≈´lo ry≈°io su Azure Found paslaugomis, tokiomis kaip Azure OpenAI, Azure AI Search, Bing Search ir kodo vykdymas, k≈´rimƒÖ.

Vis dar ne≈æinote, kuriƒÖ pasirinkti?

### Naudojimo atvejai

Pabandykime padƒóti, per≈æi≈´rƒódami keletƒÖ da≈æniausi≈≥ naudojimo atvej≈≥:

> Q: Eksperimentuoju, mokausi ir kuriu agent≈≥ program≈≥ prototipus, noriu greitai kurti ir eksperimentuoti
>

>A: AutoGen b≈´t≈≥ geras pasirinkimas ≈°iam scenarijui, nes jis orientuotas ƒØ ƒØvyki≈≥ valdomas, paskirstytas agentines programas ir palaiko pa≈æangius daugiagentƒós dizaino modelius.

> Q: Kodƒól AutoGen yra geresnis pasirinkimas nei Semantic Kernel ir Azure AI Agent Service ≈°iam naudojimo atvejui?
>
> A: AutoGen yra specialiai sukurtas ƒØvyki≈≥ valdomoms, paskirstytoms agentinƒóms programoms, todƒól jis puikiai tinka automatizuoti kodo generavimo ir duomen≈≥ analizƒós u≈æduotis. Jis suteikia reikiamus ƒØrankius ir galimybes efektyviai kurti sudƒótingas daugiagentƒós sistemas.

>Q: Atrodo, kad Azure AI Agent Service taip pat galƒót≈≥ veikti ƒçia, jis turi ƒØrankius kodo generavimui ir daugiau?

>
> A: Taip, Azure AI Agent Service yra platformos paslauga agentams ir turi ƒØmontuotas galimybes keliems modeliams, Azure AI Search, Bing Search ir Azure Functions. Tai leid≈æia lengvai kurti agentus Foundry portale ir diegti juos masteliu.
 
> Q: Vis dar nesuprantu, tiesiog duokite vienƒÖ variantƒÖ
>
> A: Puikus pasirinkimas yra pirmiausia kurti savo programƒÖ Semantic Kernel ir tada naudoti Azure AI Agent Service savo agentui diegti. ≈†is po≈æi≈´ris leid≈æia lengvai i≈°saugoti savo agentus, tuo paƒçiu pasinaudojant galimybe kurti daugiagentƒós sistemas Semantic Kernel. Be to, Semantic Kernel turi jungtƒØ AutoGen, todƒól lengva naudoti abi sistemas kartu.

Apibendrinkime pagrindinius skirtumus lentelƒóje:

| Sistema | Fokusas | Pagrindinƒós sƒÖvokos | Naudojimo atvejai |
| --- | --- | --- | --- |
| AutoGen | ƒÆvyki≈≥ valdomos, paskirstytos agentinƒós programos | Agentai, Personos, Funkcijos, Duomenys | Kodo generavimas, duomen≈≥ analizƒós u≈æduotys |
| Semantic Kernel | ≈Ωmogaus tipo teksto turinio supratimas ir generavimas | Agentai, Moduliniai komponentai, Bendradarbiavimas | Nat≈´ralios kalbos supratimas, turinio generavimas |
| Azure AI Agent Service | Lankst≈´s modeliai, ƒØmonƒós saugumas, Kodo generavimas, ƒÆranki≈≥ naudojimas | Modularumas, Bendradarbiavimas, Proces≈≥ orkestracija | Saugus, mastelio keiƒçiamas ir lankstus AI agent≈≥ diegimas |

Koks yra idealus naudojimo atvejis kiekvienai i≈° ≈°i≈≥ sistem≈≥?

## Ar galiu tiesiogiai integruoti savo esamus Azure ekosistemos ƒØrankius, ar man reikia atskir≈≥ sprendim≈≥?

Atsakymas yra taip, galite tiesiogiai integruoti savo esamus Azure ekosistemos ƒØrankius su Azure AI Agent Service, ypaƒç todƒól, kad jis buvo sukurtas veikti skland≈æiai su kitomis Azure paslaugomis. Pavyzd≈æiui, galite integruoti Bing, Azure AI Search ir Azure Functions. Taip pat yra gili integracija su Azure AI Foundry.

Naudojant AutoGen ir Semantic Kernel, taip pat galima integruoti su Azure paslaugomis, taƒçiau gali tekti i≈°kviesti Azure paslaugas i≈° savo kodo. Kitas b≈´das integruoti yra naudoti Azure SDK, kad sƒÖveikautumƒóte su Azure paslaugomis i≈° savo agent≈≥. Be to, kaip buvo minƒóta, galite naudoti Azure AI Agent Service kaip orkestratori≈≥ savo agentams, sukurtiems AutoGen arba Semantic Kernel, kas suteikt≈≥ lengvƒÖ prieigƒÖ prie Azure ekosistemos.

### Turite daugiau klausim≈≥ apie AI Agent Framework?

Prisijunkite prie [Azure AI Foundry Discord](https://aka.ms/ai-agents/discord), kad susipa≈æintumƒóte su kitais besimokanƒçiais, dalyvautumƒóte konsultacij≈≥ valandose ir gautumƒóte atsakymus ƒØ savo AI agent≈≥ klausimus.

## Nuorodos

-

---

**Atsakomybƒós apribojimas**:  
≈†is dokumentas buvo i≈°verstas naudojant AI vertimo paslaugƒÖ [Co-op Translator](https://github.com/Azure/co-op-translator). Nors siekiame tikslumo, pra≈°ome atkreipti dƒómesƒØ, kad automatiniai vertimai gali turƒóti klaid≈≥ ar netikslum≈≥. Originalus dokumentas jo gimtƒÖja kalba turƒót≈≥ b≈´ti laikomas autoritetingu ≈°altiniu. Kritinei informacijai rekomenduojama naudoti profesional≈≥ ≈æmogaus vertimƒÖ. Mes neprisiimame atsakomybƒós u≈æ nesusipratimus ar klaidingus interpretavimus, atsiradusius dƒól ≈°io vertimo naudojimo.