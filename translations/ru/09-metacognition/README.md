<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f0deef171fc3a68d5d3d770a8bfb03d",
  "translation_date": "2025-08-29T12:22:34+00:00",
  "source_file": "09-metacognition/README.md",
  "language_code": "ru"
}
-->
[![Многокомпонентный дизайн](../../../translated_images/lesson-9-thumbnail.38059e8af1a5b71d890c92f576f933c6a307c691339dca7e8ca6ea75a8d857a1.ru.png)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Нажмите на изображение выше, чтобы посмотреть видео этого урока)_
# Метакогниция в AI-агентах

## Введение

Добро пожаловать на урок о метакогниции в AI-агентах! Этот раздел предназначен для начинающих, которые хотят узнать, как AI-агенты могут размышлять о собственных процессах мышления. К концу урока вы поймете ключевые концепции и получите практические примеры применения метакогниции в дизайне AI-агентов.

## Цели обучения

После завершения урока вы сможете:

1. Понять последствия циклов рассуждений в определении агентов.
2. Использовать методы планирования и оценки для помощи агентам в самокоррекции.
3. Создавать собственных агентов, способных манипулировать кодом для выполнения задач.

## Введение в метакогницию

Метакогниция относится к высшим когнитивным процессам, которые включают размышления о собственном мышлении. Для AI-агентов это означает способность оценивать и корректировать свои действия на основе самосознания и прошлого опыта. Метакогниция, или "мышление о мышлении", является важной концепцией в разработке агентных AI-систем. Она включает осознание AI-системами своих внутренних процессов и способность мониторить, регулировать и адаптировать свое поведение. Это похоже на то, как мы оцениваем ситуацию или анализируем проблему. Такое самосознание помогает AI-системам принимать более взвешенные решения, выявлять ошибки и улучшать свою производительность со временем — что снова возвращает нас к тесту Тьюринга и дебатам о том, захватит ли AI мир.

В контексте агентных AI-систем метакогниция помогает решать несколько задач, таких как:
- Прозрачность: Обеспечение способности AI-систем объяснять свои рассуждения и решения.
- Рассуждение: Улучшение способности AI-систем синтезировать информацию и принимать обоснованные решения.
- Адаптация: Позволяет AI-системам приспосабливаться к новым условиям и изменяющимся обстоятельствам.
- Восприятие: Повышение точности AI-систем в распознавании и интерпретации данных из окружающей среды.

### Что такое метакогниция?

Метакогниция, или "мышление о мышлении", — это высший когнитивный процесс, включающий самосознание и саморегуляцию собственных когнитивных процессов. В области AI метакогниция позволяет агентам оценивать и адаптировать свои стратегии и действия, что приводит к улучшению навыков решения проблем и принятия решений. Понимая метакогницию, вы сможете разрабатывать AI-агентов, которые будут не только более умными, но и более адаптивными и эффективными. В истинной метакогниции AI явно рассуждает о собственных рассуждениях.

Пример: «Я приоритизировал более дешевые рейсы, потому что... возможно, я упустил прямые рейсы, так что давайте перепроверим».
Отслеживание того, как или почему был выбран определенный маршрут.
- Замечание, что ошибки возникли из-за чрезмерной зависимости от предпочтений пользователя в прошлый раз, и модификация стратегии принятия решений, а не только конечной рекомендации.
- Диагностика шаблонов, например: «Когда я вижу, что пользователь упоминает "слишком многолюдно", я должен не только исключить определенные достопримечательности, но и пересмотреть свой метод выбора "лучших достопримечательностей", если я всегда ранжирую их по популярности».

### Важность метакогниции в AI-агентах

Метакогниция играет ключевую роль в дизайне AI-агентов по нескольким причинам:

![Важность метакогниции](../../../translated_images/importance-of-metacognition.b381afe9aae352f7734c8628ea3f4b23084634b791c5a120c76a02bb7eeeb7ec.ru.png)

- Саморефлексия: Агенты могут оценивать свою производительность и выявлять области для улучшения.
- Адаптивность: Агенты могут изменять свои стратегии на основе прошлого опыта и изменяющихся условий.
- Исправление ошибок: Агенты могут самостоятельно выявлять и исправлять ошибки, что приводит к более точным результатам.
- Управление ресурсами: Агенты могут оптимизировать использование ресурсов, таких как время и вычислительная мощность, планируя и оценивая свои действия.

## Компоненты AI-агента

Прежде чем углубляться в процессы метакогниции, важно понять основные компоненты AI-агента. AI-агент обычно состоит из:

- Персона: Личность и характеристики агента, которые определяют, как он взаимодействует с пользователями.
- Инструменты: Возможности и функции, которые агент может выполнять.
- Навыки: Знания и опыт, которыми обладает агент.

Эти компоненты работают вместе, создавая "единицу экспертизы", способную выполнять конкретные задачи.

**Пример**:
Рассмотрим туристического агента, который не только планирует ваш отпуск, но и корректирует маршрут на основе данных в реальном времени и опыта предыдущих путешествий клиентов.

### Пример: Метакогниция в сервисе туристического агента

Представьте, что вы разрабатываете сервис туристического агента на базе AI. Этот агент, "Туристический агент", помогает пользователям планировать их отпуска. Чтобы внедрить метакогницию, Туристический агент должен оценивать и корректировать свои действия на основе самосознания и прошлого опыта. Вот как метакогниция может сыграть роль:

#### Текущая задача

Текущая задача — помочь пользователю спланировать поездку в Париж.

#### Шаги для выполнения задачи

1. **Сбор предпочтений пользователя**: Спросите пользователя о датах поездки, бюджете, интересах (например, музеи, кухня, шопинг) и любых специфических требованиях.
2. **Получение информации**: Найдите варианты рейсов, жилья, достопримечательностей и ресторанов, которые соответствуют предпочтениям пользователя.
3. **Генерация рекомендаций**: Предоставьте персонализированный маршрут с деталями рейсов, бронирования отелей и предложенными мероприятиями.
4. **Корректировка на основе обратной связи**: Спросите пользователя о его мнении по поводу рекомендаций и внесите необходимые изменения.

#### Необходимые ресурсы

- Доступ к базам данных бронирования рейсов и отелей.
- Информация о достопримечательностях и ресторанах Парижа.
- Данные обратной связи от предыдущих взаимодействий с пользователями.

#### Опыт и саморефлексия

Туристический агент использует метакогницию для оценки своей производительности и обучения на основе прошлого опыта. Например:

1. **Анализ обратной связи пользователя**: Туристический агент изучает обратную связь, чтобы определить, какие рекомендации были хорошо восприняты, а какие — нет. Он корректирует свои будущие предложения соответственно.
2. **Адаптивность**: Если пользователь ранее упоминал, что не любит многолюдные места, Туристический агент в будущем избегает рекомендаций популярных туристических мест в часы пик.
3. **Исправление ошибок**: Если Туристический агент допустил ошибку в прошлом бронировании, например, предложил отель, который был полностью забронирован, он учится более тщательно проверять доступность перед рекомендацией.

#### Практический пример для разработчиков

Вот упрощенный пример кода Туристического агента, который включает метакогницию:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Search for flights, hotels, and attractions based on preferences
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Analyze feedback and adjust future recommendations
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Почему метакогниция важна

- **Саморефлексия**: Агенты могут анализировать свою производительность и выявлять области для улучшения.
- **Адаптивность**: Агенты могут изменять стратегии на основе обратной связи и изменяющихся условий.
- **Исправление ошибок**: Агенты могут самостоятельно выявлять и исправлять ошибки.
- **Управление ресурсами**: Агенты могут оптимизировать использование ресурсов, таких как время и вычислительная мощность.

Внедряя метакогницию, Туристический агент может предоставлять более персонализированные и точные рекомендации, улучшая общий пользовательский опыт.

---

## 2. Планирование в агентах

Планирование — это важный компонент поведения AI-агента. Оно включает в себя определение шагов, необходимых для достижения цели, с учетом текущего состояния, ресурсов и возможных препятствий.

### Элементы планирования

- **Текущая задача**: Четко определить задачу.
- **Шаги для выполнения задачи**: Разбить задачу на управляемые этапы.
- **Необходимые ресурсы**: Определить необходимые ресурсы.
- **Опыт**: Использовать прошлый опыт для информирования планирования.

**Пример**:
Вот шаги, которые Туристический агент должен предпринять, чтобы эффективно помочь пользователю спланировать поездку:

### Шаги для Туристического агента

1. **Сбор предпочтений пользователя**
   - Спросите пользователя о деталях его поездки: даты, бюджет, интересы и любые специфические требования.
   - Примеры: «Когда вы планируете путешествие?» «Какой у вас бюджет?» «Какие виды деятельности вам нравятся в отпуске?»

2. **Получение информации**
   - Найдите подходящие варианты путешествия на основе предпочтений пользователя.
   - **Рейсы**: Найдите доступные рейсы в рамках бюджета и предпочтительных дат путешествия.
   - **Жилье**: Найдите отели или арендуемые помещения, которые соответствуют предпочтениям пользователя по местоположению, цене и удобствам.
   - **Достопримечательности и рестораны**: Определите популярные достопримечательности, мероприятия и варианты питания, которые соответствуют интересам пользователя.

3. **Генерация рекомендаций**
   - Скомпилируйте полученную информацию в персонализированный маршрут.
   - Предоставьте детали, такие как варианты рейсов, бронирование отелей и предложенные мероприятия, убедившись, что рекомендации соответствуют предпочтениям пользователя.

4. **Представление маршрута пользователю**
   - Поделитесь предложенным маршрутом с пользователем для его ознакомления.
   - Пример: «Вот предложенный маршрут для вашей поездки в Париж. Он включает детали рейсов, бронирование отелей и список рекомендованных мероприятий и ресторанов. Дайте знать, что вы думаете!»

5. **Сбор обратной связи**
   - Спросите пользователя о его мнении по поводу предложенного маршрута.
   - Примеры: «Вам нравятся варианты рейсов?» «Отель подходит для ваших нужд?» «Есть ли мероприятия, которые вы хотели бы добавить или убрать?»

6. **Корректировка на основе обратной связи**
   - Измените маршрут на основе обратной связи пользователя.
   - Внесите необходимые изменения в рекомендации по рейсам, жилью и мероприятиям, чтобы лучше соответствовать предпочтениям пользователя.

7. **Окончательное подтверждение**
   - Представьте обновленный маршрут пользователю для окончательного подтверждения.
   - Пример: «Я внес изменения на основе вашей обратной связи. Вот обновленный маршрут. Все ли вас устраивает?»

8. **Бронирование и подтверждение**
   - После одобрения маршрута пользователем, приступите к бронированию рейсов, жилья и любых заранее запланированных мероприятий.
   - Отправьте пользователю детали подтверждения.

9. **Предоставление постоянной поддержки**
   - Оставайтесь доступными для помощи пользователю с любыми изменениями или дополнительными запросами до и во время поездки.
   - Пример: «Если вам понадобится дополнительная помощь во время поездки, не стесняйтесь обращаться ко мне в любое время!»

### Пример взаимодействия

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage within a booing request
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Корректирующая система RAG

Сначала давайте разберемся в разнице между инструментом RAG и предварительной загрузкой контекста.

![RAG vs Загрузка контекста](../../../translated_images/rag-vs-context.9eae588520c00921f531e4dc788992e8a7b69b6ff7c9eaa69fb9bc83ad243504.ru.png)

### Генерация с дополнением извлечения (RAG)

RAG объединяет систему извлечения с генеративной моделью. Когда поступает запрос, система извлечения получает релевантные документы или данные из внешнего источника, и эта информация используется для дополнения входных данных генеративной модели. Это помогает модели генерировать более точные и контекстуально релевантные ответы.

В системе RAG агент извлекает релевантную информацию из базы знаний и использует ее для генерации подходящих ответов или действий.

### Корректирующий подход RAG

Корректирующий подход RAG фокусируется на использовании техник RAG для исправления ошибок и повышения точности AI-агентов. Это включает:

1. **Техника подсказок**: Использование специфических подсказок для направления агента в извлечении релевантной информации.
2. **Инструмент**: Реализация алгоритмов и механизмов, которые позволяют агенту оценивать релевантность извлеченной информации и генерировать точные ответы.
3. **Оценка**: Постоянная оценка производительности агента и внесение изменений для повышения его точности и эффективности.

#### Пример: Корректирующий RAG в поисковом агенте

Рассмотрим поискового агента, который извлекает информацию из интернета для ответа на запросы пользователей. Корректирующий подход RAG может включать:

1. **Техника подсказок**: Формулирование поисковых запросов на основе ввода пользователя.
2. **Инструмент**: Использование алгоритмов обработки естественного языка и машинного обучения для ранжирования и фильтрации результатов поиска.
3. **Оценка**: Анализ обратной связи пользователя для выявления и исправления неточностей в извлеченной информации.

### Корректирующий RAG в Туристическом агенте

Корректирующий RAG (Retrieval-Augmented Generation) улучшает способность AI извлекать и генерировать информацию, одновременно исправляя любые неточности. Давайте посмотрим, как Туристический агент может использовать корректирующий подход RAG для предоставления более точных и релевантных рекомендаций.

Это включает:

- **Техника подсказок:** Использование специфических подсказок для направления агента в извлечении релевантной информации.
- **Инструмент:** Реализация алгоритмов и механизмов, которые позволяют агенту оценивать релевантность извлеченной информации и генерировать точные ответы.
- **Оценка:** Постоянная оценка производительности агента и внесение изменений для повышения его точности и эффективности.

#### Шаги для внедрения корректирующего RAG в Туристическом агенте

1. **Первоначальное взаимодействие с пользователем**
   - Туристический агент собирает начальные предпочтения пользователя, такие как направление, даты поездки, бюджет и интересы.
   - Пример:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **Извлечение информации**
   - Туристический агент извлекает информацию о рейсах, жилье, достопримечательностях и ресторанах на основе предпочтений пользователя.
   - Пример:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **Генерация начальных рекомендаций**
   - Туристический агент использует извлеченную информацию для создания персонализированного маршрута.
   - Пример:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **Сбор обратной связи пользователя**
   - Туристический агент спрашивает пользователя о его мнении по поводу начальных рекомендаций.
   - Пример:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **Процесс корректирующего RAG**
   - **Техника подсказок**: Туристический агент формулирует новые поисковые запросы на основе обратной связи пользователя.
     - Пример:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Инструмент**: Туристический агент использует алгоритмы для ранжирования и фильтрации новых результатов поиска, уделяя внимание релевантности на основе обратной связи пользователя.
     - Пример:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Оценка**: Туристический агент постоянно оценивает релевантность и точность своих рекомендаций, анализируя обратную связь пользователя и внося необходимые изменения.
     - Пример:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### Практический пример

Вот упрощенный пример кода на Python, включающий корректирующий подход RAG в Туристическом агенте:
```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Предварительная загрузка контекста

Предварительная загрузка контекста включает загрузку релевантной информации или фона в модель перед обработкой запроса. Это означает, что модель имеет доступ к этой информации с самого начала, что помогает ей генерировать более информированные ответы без необходимости извлекать дополнительные данные в процессе.

Вот упрощенный пример того, как предварительная загрузка контекста может выглядеть для приложения туристического агента на Python:

```python
class TravelAgent:
    def __init__(self):
        # Pre-load popular destinations and their information
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Fetch destination information from pre-loaded context
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Example usage
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Объяснение

1. **Инициализация (метод `__init__`)**: Класс `TravelAgent` предварительно загружает словарь, содержащий информацию о популярных направлениях, таких как Париж, Токио, Нью-Йорк и Сидней. Этот словарь включает детали, такие как страна, валюта, язык и основные достопримечательности для каждого направления.

2. **Извлечение информации (метод `get_destination_info`)**: Когда пользователь запрашивает информацию о конкретном направлении, метод `get_destination_info` извлекает соответствующую информацию из предварительно загруженного словаря контекста.

Благодаря предварительной загрузке контекста приложение туристического агента может быстро отвечать на запросы пользователей, не извлекая эту информацию из внешнего источника в реальном времени. Это делает приложение более эффективным и отзывчивым.

### Построение плана с целью перед итерацией

Построение плана с целью включает начало с четко определенной цели или желаемого результата. Определив эту цель заранее, модель может использовать её как руководящий принцип в процессе итерации. Это помогает гарантировать, что каждая итерация приближает к достижению желаемого результата, делая процесс более эффективным и целенаправленным.

Вот пример того, как можно построить план путешествия с целью перед итерацией для туристического агента на Python:

### Сценарий

Туристический агент хочет составить индивидуальный отпуск для клиента. Цель — создать маршрут путешествия, который максимально удовлетворяет клиента, основываясь на его предпочтениях и бюджете.

### Шаги

1. Определить предпочтения и бюджет клиента.
2. Построить начальный план на основе этих предпочтений.
3. Итеративно уточнять план, оптимизируя его для удовлетворения клиента.

#### Код на Python

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Example usage
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Объяснение кода

1. **Инициализация (метод `__init__`)**: Класс `TravelAgent` инициализируется списком потенциальных направлений, каждое из которых имеет атрибуты, такие как название, стоимость и тип активности.

2. **Построение плана (метод `bootstrap_plan`)**: Этот метод создает начальный план путешествия на основе предпочтений и бюджета клиента. Он проходит по списку направлений и добавляет их в план, если они соответствуют предпочтениям клиента и укладываются в бюджет.

3. **Сопоставление предпочтений (метод `match_preferences`)**: Этот метод проверяет, соответствует ли направление предпочтениям клиента.

4. **Итерация плана (метод `iterate_plan`)**: Этот метод уточняет начальный план, пытаясь заменить каждое направление в плане на более подходящее, учитывая предпочтения клиента и бюджетные ограничения.

5. **Расчет стоимости (метод `calculate_cost`)**: Этот метод рассчитывает общую стоимость текущего плана, включая потенциальное новое направление.

#### Пример использования

- **Начальный план**: Туристический агент создает начальный план на основе предпочтений клиента к осмотру достопримечательностей и бюджета в $2000.
- **Уточненный план**: Туристический агент уточняет план, оптимизируя его для предпочтений и бюджета клиента.

Построив план с четкой целью (например, максимизация удовлетворения клиента) и итеративно уточняя его, туристический агент может создать индивидуальный и оптимизированный маршрут путешествия для клиента. Такой подход гарантирует, что план путешествия соответствует предпочтениям и бюджету клиента с самого начала и улучшается с каждой итерацией.

### Использование LLM для ранжирования и оценки

Большие языковые модели (LLM) могут использоваться для ранжирования и оценки, анализируя релевантность и качество извлеченных документов или сгенерированных ответов. Вот как это работает:

**Извлечение:** На первом этапе извлечения выбирается набор кандидатов-документов или ответов на основе запроса.

**Ранжирование:** LLM оценивает этих кандидатов и ранжирует их на основе их релевантности и качества. Этот шаг гарантирует, что наиболее релевантная и качественная информация представлена первой.

**Оценка:** LLM присваивает каждому кандидату оценку, отражающую их релевантность и качество. Это помогает выбрать лучший ответ или документ для пользователя.

Используя LLM для ранжирования и оценки, система может предоставлять более точную и контекстуально релевантную информацию, улучшая общий пользовательский опыт.

Вот пример того, как туристический агент может использовать большую языковую модель (LLM) для ранжирования и оценки туристических направлений на основе предпочтений пользователя на Python:

#### Сценарий - Путешествие на основе предпочтений

Туристический агент хочет порекомендовать клиенту лучшие направления для путешествия на основе его предпочтений. LLM поможет ранжировать и оценить направления, чтобы гарантировать, что представлены наиболее релевантные варианты.

#### Шаги:

1. Собрать предпочтения пользователя.
2. Извлечь список потенциальных направлений для путешествия.
3. Использовать LLM для ранжирования и оценки направлений на основе предпочтений пользователя.

Вот как можно обновить предыдущий пример, используя Azure OpenAI Services:

#### Требования

1. Вам нужен подписка Azure.
2. Создайте ресурс Azure OpenAI и получите свой API-ключ.

#### Пример кода на Python

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Generate a prompt for the Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Define headers and payload for the request
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Call the Azure OpenAI API to get the re-ranked and scored destinations
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Extract and return the recommendations
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Example usage
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Объяснение кода - Preference Booker

1. **Инициализация**: Класс `TravelAgent` инициализируется списком потенциальных направлений для путешествия, каждое из которых имеет атрибуты, такие как название и описание.

2. **Получение рекомендаций (метод `get_recommendations`)**: Этот метод генерирует запрос для сервиса Azure OpenAI на основе предпочтений пользователя и делает HTTP POST-запрос к API Azure OpenAI, чтобы получить ранжированные и оцененные направления.

3. **Генерация запроса (метод `generate_prompt`)**: Этот метод создает запрос для Azure OpenAI, включая предпочтения пользователя и список направлений. Запрос направляет модель к ранжированию и оценке направлений на основе предоставленных предпочтений.

4. **API-запрос**: Библиотека `requests` используется для выполнения HTTP POST-запроса к конечной точке API Azure OpenAI. Ответ содержит ранжированные и оцененные направления.

5. **Пример использования**: Туристический агент собирает предпочтения пользователя (например, интерес к осмотру достопримечательностей и разнообразной культуре) и использует сервис Azure OpenAI для получения ранжированных и оцененных рекомендаций по направлениям для путешествия.

Не забудьте заменить `your_azure_openai_api_key` на ваш фактический API-ключ Azure OpenAI и `https://your-endpoint.com/...` на фактический URL конечной точки вашего развертывания Azure OpenAI.

Используя LLM для ранжирования и оценки, туристический агент может предоставлять более персонализированные и релевантные рекомендации по путешествиям клиентам, улучшая их общий опыт.

### RAG: Техника подсказок vs Инструмент

Извлечение с дополнением генерации (RAG) может быть как техникой подсказок, так и инструментом в разработке AI-агентов. Понимание различий между ними поможет вам более эффективно использовать RAG в ваших проектах.

#### RAG как техника подсказок

**Что это?**

- Как техника подсказок, RAG включает формулирование конкретных запросов или подсказок для извлечения релевантной информации из большого корпуса или базы данных. Эта информация затем используется для генерации ответов или действий.

**Как это работает:**

1. **Формулирование подсказок**: Создайте хорошо структурированные подсказки или запросы на основе задачи или ввода пользователя.
2. **Извлечение информации**: Используйте подсказки для поиска релевантных данных из существующей базы знаний или набора данных.
3. **Генерация ответа**: Скомбинируйте извлеченную информацию с генеративными AI-моделями для создания комплексного и связного ответа.

**Пример в туристическом агенте**:

- Ввод пользователя: "Я хочу посетить музеи в Париже."
- Подсказка: "Найти лучшие музеи в Париже."
- Извлеченная информация: Детали о Лувре, Музее Орсе и т.д.
- Сгенерированный ответ: "Вот лучшие музеи в Париже: Лувр, Музей Орсе и Центр Помпиду."

#### RAG как инструмент

**Что это?**

- Как инструмент, RAG представляет собой интегрированную систему, которая автоматизирует процесс извлечения и генерации, упрощая разработчикам реализацию сложных AI-функций без необходимости вручную создавать подсказки для каждого запроса.

**Как это работает:**

1. **Интеграция**: Встроить RAG в архитектуру AI-агента, позволяя ему автоматически обрабатывать задачи извлечения и генерации.
2. **Автоматизация**: Инструмент управляет всем процессом, от получения ввода пользователя до генерации окончательного ответа, без необходимости явных подсказок для каждого шага.
3. **Эффективность**: Повышает производительность агента, упрощая процесс извлечения и генерации, обеспечивая более быстрые и точные ответы.

**Пример в туристическом агенте**:

- Ввод пользователя: "Я хочу посетить музеи в Париже."
- Инструмент RAG: Автоматически извлекает информацию о музеях и генерирует ответ.
- Сгенерированный ответ: "Вот лучшие музеи в Париже: Лувр, Музей Орсе и Центр Помпиду."

### Сравнение

| Аспект                 | Техника подсказок                                        | Инструмент                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Ручное vs Автоматическое**| Ручное формулирование подсказок для каждого запроса.               | Автоматизированный процесс извлечения и генерации.       |
| **Контроль**            | Предоставляет больше контроля над процессом извлечения.             | Упрощает и автоматизирует процесс извлечения и генерации.|
| **Гибкость**        | Позволяет создавать индивидуальные подсказки на основе конкретных потребностей.      | Более эффективен для крупномасштабных внедрений.       |
| **Сложность**         | Требует создания и настройки подсказок.                  | Легче интегрируется в архитектуру AI-агента. |

### Практические примеры

**Пример техники подсказок:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Пример инструмента:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Оценка релевантности

Оценка релевантности — это важный аспект производительности AI-агента. Она гарантирует, что информация, извлеченная и сгенерированная агентом, является подходящей, точной и полезной для пользователя. Давайте рассмотрим, как оценивать релевантность в AI-агентах, включая практические примеры и техники.

#### Основные концепции оценки релевантности

1. **Осведомленность о контексте**:
   - Агент должен понимать контекст запроса пользователя, чтобы извлекать и генерировать релевантную информацию.
   - Пример: Если пользователь спрашивает о "лучших ресторанах в Париже", агент должен учитывать предпочтения пользователя, такие как тип кухни и бюджет.

2. **Точность**:
   - Информация, предоставляемая агентом, должна быть фактически правильной и актуальной.
   - Пример: Рекомендация открытых ресторанов с хорошими отзывами, а не устаревших или закрытых вариантов.

3. **Намерение пользователя**:
   - Агент должен понимать намерение пользователя за запросом, чтобы предоставить наиболее релевантную информацию.
   - Пример: Если пользователь спрашивает о "доступных отелях", агент должен приоритизировать недорогие варианты.

4. **Обратная связь**:
   - Постоянный сбор и анализ обратной связи от пользователей помогает агенту улучшать процесс оценки релевантности.
   - Пример: Учет рейтингов и отзывов пользователей о предыдущих рекомендациях для улучшения будущих ответов.

#### Практические техники оценки релевантности

1. **Оценка релевантности**:
   - Присваивать оценку релевантности каждому извлеченному элементу на основе того, насколько хорошо он соответствует запросу и предпочтениям пользователя.
   - Пример:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Фильтрация и ранжирование**:
   - Исключать нерелевантные элементы и ранжировать оставшиеся на основе их оценок релевантности.
   - Пример:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Return top 10 relevant items
     ```

3. **Обработка естественного языка (NLP)**:
   - Использовать техники NLP для понимания запроса пользователя и извлечения релевантной информации.
   - Пример:

     ```python
     def process_query(query):
         # Use NLP to extract key information from the user's query
         processed_query = nlp(query)
         return processed_query
     ```

4. **Интеграция обратной связи от пользователей**:
   - Собирать обратную связь от пользователей о предоставленных рекомендациях и использовать её для корректировки будущих оценок релевантности.
   - Пример:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Пример: Оценка релевантности в туристическом агенте

Вот практический пример того, как туристический агент может оценивать релевантность туристических рекомендаций:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Return top 10 relevant items

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Поиск с учетом намерения

Поиск с учетом намерения включает понимание и интерпретацию скрытой цели или задачи за запросом пользователя, чтобы извлечь и сгенерировать наиболее релевантную и полезную информацию. Такой подход выходит за рамки простого сопоставления ключевых слов и фокусируется на понимании реальных потребностей и контекста пользователя.

#### Основные концепции поиска с учетом намерения

1. **Понимание намерения пользователя**:
   - Намерение пользователя можно разделить на три основные категории: информационное, навигационное и транзакционное.
     - **Информационное намерение**: Пользователь ищет информацию о теме (например, "Какие лучшие музеи в Париже?").
     - **Навигационное намерение**: Пользователь хочет перейти на определенный сайт или страницу (например, "Официальный сайт Лувра").
     - **Транзакционное намерение**: Пользователь хочет выполнить транзакцию, например, забронировать рейс или совершить покупку (например, "Забронировать рейс в Париж").

2. **Осведомленность о контексте**:
   - Анализ контекста запроса пользователя помогает точно определить его намерение. Это включает учет предыдущих взаимодействий, предпочтений пользователя и конкретных деталей текущего запроса.

3. **Обработка естественного языка (NLP)**:
   - Техники NLP используются для понимания и интерпретации запросов на естественном языке, предоставленных пользователями. Это включает задачи, такие как распознавание сущностей, анализ настроений и разбор запросов.

4. **Персонализация**:
   - Персонализация результатов поиска на основе истории пользователя, предпочтений и обратной связи улучшает релевантность извлеченной информации.
#### Практический пример: Поиск с учетом намерений в Travel Agent

Рассмотрим пример Travel Agent, чтобы понять, как можно реализовать поиск с учетом намерений.

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Понимание намерений пользователя**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Учет контекста**

   ```python
   def analyze_context(query, user_history):
       # Combine current query with user history to understand context
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Поиск и персонализация результатов**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Example search logic for informational intent
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Example search logic for navigational intent
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Example search logic for transactional intent
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Example personalization logic
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Return top 10 personalized results
   ```

5. **Пример использования**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Генерация кода как инструмент

Агенты, генерирующие код, используют модели ИИ для написания и выполнения кода, решая сложные задачи и автоматизируя процессы.

### Агенты, генерирующие код

Агенты, генерирующие код, используют генеративные модели ИИ для написания и выполнения кода. Эти агенты могут решать сложные задачи, автоматизировать процессы и предоставлять ценные инсайты, создавая и выполняя код на различных языках программирования.

#### Практические применения

1. **Автоматическая генерация кода**: Создание фрагментов кода для выполнения конкретных задач, таких как анализ данных, веб-скрейпинг или машинное обучение.
2. **SQL как RAG**: Использование SQL-запросов для извлечения и обработки данных из баз данных.
3. **Решение задач**: Создание и выполнение кода для решения конкретных задач, таких как оптимизация алгоритмов или анализ данных.

#### Пример: агент, генерирующий код для анализа данных

Представьте, что вы разрабатываете агента, генерирующего код. Вот как это может работать:

1. **Задача**: Анализировать набор данных для выявления трендов и закономерностей.
2. **Шаги**:
   - Загрузить набор данных в инструмент анализа данных.
   - Сгенерировать SQL-запросы для фильтрации и агрегации данных.
   - Выполнить запросы и получить результаты.
   - Использовать результаты для создания визуализаций и инсайтов.
3. **Необходимые ресурсы**: Доступ к набору данных, инструменты анализа данных и возможности SQL.
4. **Опыт**: Использование предыдущих результатов анализа для повышения точности и релевантности будущих анализов.

### Пример: агент, генерирующий код для Travel Agent

В этом примере мы разработаем агента, генерирующего код, Travel Agent, который помогает пользователям планировать путешествия, создавая и выполняя код. Этот агент может выполнять задачи, такие как поиск вариантов путешествия, фильтрация результатов и составление маршрута с использованием генеративного ИИ.

#### Обзор агента, генерирующего код

1. **Сбор предпочтений пользователя**: Сбор данных о предпочтениях пользователя, таких как пункт назначения, даты поездки, бюджет и интересы.
2. **Генерация кода для получения данных**: Создание фрагментов кода для извлечения данных о рейсах, отелях и достопримечательностях.
3. **Выполнение сгенерированного кода**: Выполнение сгенерированного кода для получения актуальной информации.
4. **Создание маршрута**: Компиляция полученных данных в персонализированный план путешествия.
5. **Корректировка на основе обратной связи**: Получение обратной связи от пользователя и повторная генерация кода для уточнения результатов.

#### Пошаговая реализация

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерация кода для получения данных**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Example: Generate code to search for flights based on user preferences
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Example: Generate code to search for hotels
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **Выполнение сгенерированного кода**

   ```python
   def execute_code(code):
       # Execute the generated code using exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Создание маршрута**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Корректировка на основе обратной связи**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Adjust preferences based on user feedback
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Regenerate and execute code with updated preferences
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### Использование осведомленности об окружающей среде и рассуждений

Использование схемы таблицы действительно может улучшить процесс генерации запросов, благодаря осведомленности об окружающей среде и рассуждениям.

Вот пример того, как это можно реализовать:

1. **Понимание схемы**: Система понимает схему таблицы и использует эту информацию для обоснования генерации запросов.
2. **Корректировка на основе обратной связи**: Система корректирует предпочтения пользователя на основе обратной связи и рассуждает, какие поля в схеме необходимо обновить.
3. **Генерация и выполнение запросов**: Система генерирует и выполняет запросы для получения обновленных данных о рейсах и отелях на основе новых предпочтений.

Вот обновленный пример кода на Python, который включает эти концепции:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Adjust preferences based on user feedback
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Reasoning based on schema to adjust other related preferences
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Custom logic to adjust preferences based on schema and feedback
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Generate code to fetch flight data based on updated preferences
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Generate code to fetch hotel data based on updated preferences
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Simulate execution of code and return mock data
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Generate itinerary based on flights, hotels, and attractions
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Example schema
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Example usage
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Regenerate and execute code with updated preferences
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Объяснение - бронирование на основе обратной связи

1. **Осведомленность о схеме**: Словарь `schema` определяет, как предпочтения должны корректироваться на основе обратной связи. Он включает поля, такие как `favorites` и `avoid`, с соответствующими корректировками.
2. **Корректировка предпочтений (метод `adjust_based_on_feedback`)**: Этот метод корректирует предпочтения на основе обратной связи пользователя и схемы.
3. **Корректировки на основе окружающей среды (метод `adjust_based_on_environment`)**: Этот метод настраивает корректировки на основе схемы и обратной связи.
4. **Генерация и выполнение запросов**: Система генерирует код для получения обновленных данных о рейсах и отелях на основе скорректированных предпочтений и симулирует выполнение этих запросов.
5. **Создание маршрута**: Система создает обновленный маршрут на основе новых данных о рейсах, отелях и достопримечательностях.

Благодаря тому, что система учитывает окружающую среду и рассуждает на основе схемы, она может генерировать более точные и релевантные запросы, что приводит к лучшим рекомендациям и более персонализированному пользовательскому опыту.

### Использование SQL как техники Retrieval-Augmented Generation (RAG)

SQL (язык структурированных запросов) — мощный инструмент для взаимодействия с базами данных. При использовании в рамках подхода Retrieval-Augmented Generation (RAG) SQL может извлекать релевантные данные из баз данных, чтобы информировать и генерировать ответы или действия в ИИ-агентах. Давайте рассмотрим, как SQL может быть использован как техника RAG в контексте Travel Agent.

#### Основные концепции

1. **Взаимодействие с базой данных**:
   - SQL используется для выполнения запросов к базам данных, извлечения релевантной информации и обработки данных.
   - Пример: Получение данных о рейсах, информации об отелях и достопримечательностях из базы данных путешествий.

2. **Интеграция с RAG**:
   - SQL-запросы генерируются на основе ввода и предпочтений пользователя.
   - Полученные данные используются для генерации персонализированных рекомендаций или действий.

3. **Динамическая генерация запросов**:
   - ИИ-агент генерирует динамические SQL-запросы на основе контекста и потребностей пользователя.
   - Пример: Настройка SQL-запросов для фильтрации результатов по бюджету, датам и интересам.

#### Применения

- **Автоматическая генерация кода**: Создание фрагментов кода для выполнения конкретных задач.
- **SQL как RAG**: Использование SQL-запросов для обработки данных.
- **Решение задач**: Создание и выполнение кода для решения задач.

**Пример**:
Агент анализа данных:

1. **Задача**: Анализировать набор данных для выявления трендов.
2. **Шаги**:
   - Загрузить набор данных.
   - Сгенерировать SQL-запросы для фильтрации данных.
   - Выполнить запросы и получить результаты.
   - Создать визуализации и инсайты.
3. **Ресурсы**: Доступ к набору данных, возможности SQL.
4. **Опыт**: Использование предыдущих результатов для улучшения будущих анализов.

#### Практический пример: использование SQL в Travel Agent

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерация SQL-запросов**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **Выполнение SQL-запросов**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Генерация рекомендаций**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Примеры SQL-запросов

1. **Запрос рейсов**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Запрос отелей**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Запрос достопримечательностей**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Используя SQL как часть техники Retrieval-Augmented Generation (RAG), такие ИИ-агенты, как Travel Agent, могут динамически извлекать и использовать релевантные данные для предоставления точных и персонализированных рекомендаций.

### Пример метакогниции

Чтобы продемонстрировать реализацию метакогниции, создадим простого агента, который *анализирует свой процесс принятия решений* при решении задачи. В этом примере мы разработаем систему, где агент пытается оптимизировать выбор отеля, но затем оценивает свои рассуждения и корректирует стратегию, если допускает ошибки или делает субоптимальный выбор.

Мы смоделируем это на простом примере, где агент выбирает отели на основе комбинации цены и качества, но будет "анализировать" свои решения и корректировать их.

#### Как это иллюстрирует метакогницию:

1. **Первоначальное решение**: Агент выбирает самый дешевый отель, не учитывая влияние качества.
2. **Рефлексия и оценка**: После первоначального выбора агент проверяет, является ли отель "плохим" выбором, используя обратную связь пользователя. Если качество отеля оказалось слишком низким, агент анализирует свои рассуждения.
3. **Корректировка стратегии**: Агент корректирует свою стратегию, переходя от "самого дешевого" к "самому качественному", улучшая процесс принятия решений в будущих итерациях.

Вот пример:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Stores the hotels chosen previously
        self.corrected_choices = []  # Stores the corrected choices
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Available strategies

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Let's assume we have some user feedback that tells us whether the last choice was good or not
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Adjust strategy if the previous choice was unsatisfactory
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Simulate a list of hotels (price and quality)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Create an agent
agent = HotelRecommendationAgent()

# Step 1: The agent recommends a hotel using the "cheapest" strategy
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Step 2: The agent reflects on the choice and adjusts strategy if necessary
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Step 3: The agent recommends again, this time using the adjusted strategy
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Метакогнитивные способности агента

Ключевым моментом здесь является способность агента:
- Оценивать свои предыдущие выборы и процесс принятия решений.
- Корректировать стратегию на основе этой рефлексии, то есть метакогниция в действии.

Это простая форма метакогниции, где система способна корректировать процесс рассуждений на основе внутренней обратной связи.

### Заключение

Метакогниция — мощный инструмент, который может значительно расширить возможности ИИ-агентов. Включив метакогнитивные процессы, вы можете разработать агентов, которые будут более умными, адаптивными и эффективными. Используйте дополнительные ресурсы, чтобы глубже изучить увлекательный мир метакогниции в ИИ-агентах.

### Остались вопросы о шаблоне проектирования метакогниции?

Присоединяйтесь к [Azure AI Foundry Discord](https://aka.ms/ai-agents/discord), чтобы встретиться с другими учащимися, посетить офисные часы и получить ответы на свои вопросы о ИИ-агентах.

## Предыдущий урок

[Шаблон проектирования мультиагентов](../08-multi-agent/README.md)

## Следующий урок

[ИИ-агенты в продакшене](../10-ai-agents-production/README.md)

---

**Отказ от ответственности**:  
Этот документ был переведен с помощью сервиса автоматического перевода [Co-op Translator](https://github.com/Azure/co-op-translator). Несмотря на наши усилия по обеспечению точности, автоматические переводы могут содержать ошибки или неточности. Оригинальный документ на его родном языке следует считать авторитетным источником. Для получения критически важной информации рекомендуется профессиональный перевод человеком. Мы не несем ответственности за любые недоразумения или неправильные интерпретации, возникающие в результате использования данного перевода.