<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5cc6836626047aa055e8960c8484a7d0",
  "translation_date": "2025-08-30T00:13:00+00:00",
  "source_file": "11-agentic-protocols/code_samples/mcp-agents/README.md",
  "language_code": "sl"
}
-->
# Gradnja sistemov za komunikacijo med agenti z MCP

> Na kratko - Ali lahko zgradite komunikacijo Agent2Agent na MCP? Da!

MCP se je moƒçno razvil onkraj svojega prvotnega cilja "zagotavljanja konteksta za LLM-je". Z nedavnimi izbolj≈°avami, kot so [ponovno vzpostavljivi tokovi](https://modelcontextprotocol.io/docs/concepts/transports#resumability-and-redelivery), [elicitation](https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation), [sampling](https://modelcontextprotocol.io/specification/2025-06-18/client/sampling) in obvestila ([napredek](https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress) in [viri](https://modelcontextprotocol.io/specification/2025-06-18/schema#resourceupdatednotification)), MCP zdaj ponuja robustno osnovo za gradnjo kompleksnih sistemov za komunikacijo med agenti.

## Napaƒçno razumevanje agentov in orodij

Ko vedno veƒç razvijalcev raziskuje orodja z agentnimi vedenji (dolgotrajno delovanje, potreba po dodatnih vnosih med izvajanjem itd.), se pogosto pojavi napaƒçno prepriƒçanje, da MCP ni primeren, predvsem zato, ker so se zgodnji primeri njegovega orodja osredotoƒçali na preproste vzorce zahteva-odgovor.

To prepriƒçanje je zastarelo. Specifikacija MCP je bila v zadnjih mesecih bistveno izbolj≈°ana z zmogljivostmi, ki zapolnjujejo vrzel za gradnjo dolgotrajnih agentnih vedenj:

- **Tokovi in delni rezultati**: Posodobitve napredka v realnem ƒçasu med izvajanjem
- **Ponovna vzpostavitev**: Odjemalci se lahko ponovno pove≈æejo in nadaljujejo po prekinitvi
- **Trajnost**: Rezultati pre≈æivijo ponovni zagon stre≈ænika (npr. prek povezav do virov)
- **Veƒçkratni obrati**: Interaktivni vnosi med izvajanjem prek elicitation in sampling

Te funkcije je mogoƒçe sestaviti za omogoƒçanje kompleksnih agentnih in veƒçagentnih aplikacij, vse na MCP protokolu.

Za referenco bomo agenta imenovali "orodje", ki je na voljo na MCP stre≈æniku. To pomeni obstoj gostiteljske aplikacije, ki implementira MCP odjemalca, vzpostavi sejo z MCP stre≈ænikom in lahko kliƒçe agenta.

## Kaj naredi MCP orodje "agentno"?

Preden se poglobimo v implementacijo, opredelimo, katere infrastrukturne zmogljivosti so potrebne za podporo dolgotrajnih agentov.

> Agenta bomo opredelili kot entiteto, ki lahko deluje avtonomno dalj≈°e obdobje in je sposobna obravnavati kompleksne naloge, ki lahko zahtevajo veƒç interakcij ali prilagoditev na podlagi povratnih informacij v realnem ƒçasu.

### 1. Tokovi in delni rezultati

Tradicionalni vzorci zahteva-odgovor ne delujejo za dolgotrajne naloge. Agenti morajo zagotoviti:

- Posodobitve napredka v realnem ƒçasu
- Vmesne rezultate

**Podpora MCP**: Obvestila o posodobitvah virov omogoƒçajo tokove delnih rezultatov, ƒçeprav to zahteva skrbno naƒçrtovanje, da se izognemo konfliktom z modelom 1:1 zahteva/odgovor JSON-RPC.

| Funkcija                  | Primer uporabe                                                                                                                                                                       | Podpora MCP                                                                                |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------ |
| Posodobitve napredka v realnem ƒçasu | Uporabnik zahteva nalogo migracije kode. Agent posreduje napredek: "10% - Analiziranje odvisnosti... 25% - Pretvarjanje TypeScript datotek... 50% - Posodabljanje uvozov..."          | ‚úÖ Obvestila o napredku                                                                  |
| Delni rezultati           | Naloga "Ustvari knjigo" posreduje delne rezultate, npr. 1) Oris zgodbe, 2) Seznam poglavij, 3) Vsako dokonƒçano poglavje. Gostitelj lahko pregleda, prekliƒçe ali preusmeri na kateri koli stopnji. | ‚úÖ Obvestila je mogoƒçe "raz≈°iriti", da vkljuƒçujejo delne rezultate, glej predloge na PR 383, 776 |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>Slika 1:</strong> Ta diagram prikazuje, kako MCP agent posreduje posodobitve napredka v realnem ƒçasu in delne rezultate gostiteljski aplikaciji med dolgotrajno nalogo, kar omogoƒça uporabniku spremljanje izvajanja v realnem ƒçasu.
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)

    User->>Host: Start long task
    Host->>Server: Call agent_tool()

    loop Progress Updates
        Server-->>Host: Progress + partial results
        Host-->>User: Stream updates
    end

    Server-->>Host: ‚úÖ Final result
    Host-->>User: Complete
```

### 2. Ponovna vzpostavitev

Agenti morajo obvladovati prekinitve omre≈æja brez te≈æav:

- Ponovna povezava po prekinitvi (odjemalca)
- Nadaljevanje tam, kjer so konƒçali (ponovna dostava sporoƒçil)

**Podpora MCP**: MCP StreamableHTTP transport danes podpira ponovno vzpostavitev sej in ponovno dostavo sporoƒçil z ID-ji sej in ID-ji zadnjih dogodkov. Pomembno je, da mora stre≈ænik implementirati EventStore, ki omogoƒça ponovitve dogodkov ob ponovni povezavi odjemalca.  
Omeniti velja, da obstaja predlog skupnosti (PR #975), ki raziskuje transportno neodvisne ponovno vzpostavljive tokove.

| Funkcija      | Primer uporabe                                                                                                                                                   | Podpora MCP                                                                |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| Ponovna vzpostavitev | Odjemalec se prekine med dolgotrajno nalogo. Ob ponovni povezavi se seja nadaljuje z ponovitvijo zamujenih dogodkov, brezhibno nadaljuje tam, kjer je konƒçala. | ‚úÖ StreamableHTTP transport z ID-ji sej, ponovitvijo dogodkov in EventStore |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>Slika 2:</strong> Ta diagram prikazuje, kako MCP-jev StreamableHTTP transport in EventStore omogoƒçata brezhibno ponovno vzpostavitev sej: ƒçe se odjemalec prekine, se lahko ponovno pove≈æe in ponovi zamujene dogodke, nadaljuje nalogo brez izgube napredka.
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)
    participant Store as Event Store

    User->>Host: Start task
    Host->>Server: Call tool [session: abc123]
    Server->>Store: Save events

    Note over Host,Server: üí• Connection lost

    Host->>Server: Reconnect [session: abc123]
    Store-->>Server: Replay events
    Server-->>Host: Catch up + continue
    Host-->>User: ‚úÖ Complete
```

### 3. Trajnost

Dolgotrajni agenti potrebujejo trajno stanje:

- Rezultati pre≈æivijo ponovni zagon stre≈ænika
- Stanje je mogoƒçe pridobiti zunaj seje
- Sledenje napredku med sejami

**Podpora MCP**: MCP zdaj podpira vrsto vrnitve Resource link za klice orodij. Danes je mo≈æen vzorec zasnove orodja, ki ustvari vir in takoj vrne povezavo do vira. Orodje lahko nadaljuje z obravnavo naloge v ozadju in posodablja vir. Odjemalec lahko nato izbere, ali bo preverjal stanje tega vira za pridobitev delnih ali celotnih rezultatov (glede na to, katere posodobitve virov stre≈ænik zagotavlja) ali se naroƒçil na vir za obvestila o posodobitvah.

Ena omejitev tukaj je, da lahko preverjanje virov ali naroƒçanje na posodobitve porabi vire, kar ima posledice pri veƒçjem obsegu. Obstaja odprt predlog skupnosti (vkljuƒçno z #992), ki raziskuje mo≈ænost vkljuƒçitve webhookov ali spro≈æilcev, ki jih stre≈ænik lahko pokliƒçe za obve≈°ƒçanje odjemalca/gostiteljske aplikacije o posodobitvah.

| Funkcija    | Primer uporabe                                                                                                                                        | Podpora MCP                                                        |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| Trajnost    | Stre≈ænik se zru≈°i med nalogo migracije podatkov. Rezultati in napredek pre≈æivijo ponovni zagon, odjemalec lahko preveri stanje in nadaljuje iz trajnega vira. | ‚úÖ Povezave do virov s trajnim shranjevanjem in obvestili o stanju |

Danes je pogost vzorec zasnove orodja, ki ustvari vir in takoj vrne povezavo do vira. Orodje lahko v ozadju obravnava nalogo, izdaja obvestila o virih, ki slu≈æijo kot posodobitve napredka ali vkljuƒçujejo delne rezultate, in po potrebi posodablja vsebino v viru.

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>Slika 3:</strong> Ta diagram prikazuje, kako MCP agenti uporabljajo trajne vire in obvestila o stanju za zagotavljanje, da dolgotrajne naloge pre≈æivijo ponovne zagone stre≈ænika, kar omogoƒça odjemalcem preverjanje napredka in pridobivanje rezultatov tudi po napakah.
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)
    participant DB as Persistent Storage

    User->>Host: Start task
    Host->>Server: Call tool
    Server->>DB: Create resource + updates
    Server-->>Host: üîó Resource link

    Note over Server: üí• Server restart

    User->>Host: Check status
    Host->>Server: Get resource
    Server->>DB: Load state
    Server-->>Host: Current progress
    Server->>DB: Complete + notify
    Host-->>User: ‚úÖ Complete
```

### 4. Veƒçkratne interakcije

Agenti pogosto potrebujejo dodatne vnose med izvajanjem:

- ƒålove≈°ka pojasnila ali odobritve
- AI pomoƒç pri kompleksnih odloƒçitvah
- Dinamiƒçna prilagoditev parametrov

**Podpora MCP**: Popolnoma podprto prek sampling (za AI vnose) in elicitation (za ƒçlove≈°ke vnose).

| Funkcija                 | Primer uporabe                                                                                                                                     | Podpora MCP                                           |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
| Veƒçkratne interakcije    | Agent za rezervacijo potovanj zahteva potrditev cene od uporabnika, nato pa prosi AI za povzetek podatkov o potovanju, preden dokonƒça transakcijo. | ‚úÖ Elicitation za ƒçlove≈°ke vnose, sampling za AI vnose |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>Slika 4:</strong> Ta diagram prikazuje, kako MCP agenti lahko interaktivno pridobijo ƒçlove≈°ke vnose ali zahtevajo AI pomoƒç med izvajanjem, kar podpira kompleksne, veƒçkratne delovne tokove, kot so potrditve in dinamiƒçno odloƒçanje.
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)

    User->>Host: Book flight
    Host->>Server: Call travel_agent

    Server->>Host: Elicitation: "Confirm $500?"
    Note over Host: Elicitation callback (if available)
    Host->>User: üí∞ Confirm price?
    User->>Host: "Yes"
    Host->>Server: Confirmed

    Server->>Host: Sampling: "Summarize data"
    Note over Host: AI callback (if available)
    Host->>Server: Report summary

    Server->>Host: ‚úÖ Flight booked
```

## Implementacija dolgotrajnih agentov na MCP - Pregled kode

Kot del tega ƒçlanka ponujamo [repozitorij kode](https://github.com/victordibia/ai-tutorials/tree/main/MCP%20Agents), ki vsebuje popolno implementacijo dolgotrajnih agentov z uporabo MCP Python SDK z StreamableHTTP transportom za ponovno vzpostavitev sej in ponovno dostavo sporoƒçil. Implementacija prikazuje, kako je mogoƒçe zmogljivosti MCP sestaviti za omogoƒçanje sofisticiranih agentnih vedenj.

Specifiƒçno implementiramo stre≈ænik z dvema glavnima agentnima orodjema:

- **Agent za potovanja** - Simulira storitev rezervacije potovanj s potrditvijo cene prek elicitation
- **Raziskovalni agent** - Izvaja raziskovalne naloge s povzetki, ki jih omogoƒça AI, prek sampling

Oba agenta prikazujeta posodobitve napredka v realnem ƒçasu, interaktivne potrditve in popolne zmogljivosti ponovne vzpostavitve sej.

### Kljuƒçni koncepti implementacije

Naslednji odseki prikazujejo implementacijo agenta na strani stre≈ænika in obravnavo gostitelja na strani odjemalca za vsako zmogljivost:

#### Tokovi in posodobitve napredka - Stanje naloge v realnem ƒçasu

Tokovi omogoƒçajo agentom, da med dolgotrajnimi nalogami posredujejo posodobitve napredka v realnem ƒçasu, kar uporabnikom omogoƒça spremljanje stanja naloge in vmesnih rezultatov.

**Implementacija na stre≈æniku (agent po≈°ilja obvestila o napredku):**

```python
# From server/server.py - Travel agent sending progress updates
for i, step in enumerate(steps):
    await ctx.session.send_progress_notification(
        progress_token=ctx.request_id,
        progress=i * 25,
        total=100,
        message=step,
        related_request_id=str(ctx.request_id)
    )
    await anyio.sleep(2)  # Simulate work

# Alternative: Log messages for detailed step-by-step updates
await ctx.session.send_log_message(
    level="info",
    data=f"Processing step {current_step}/{steps} ({progress_percent}%)",
    logger="long_running_agent",
    related_request_id=ctx.request_id,
)
```

**Implementacija na odjemalcu (gostitelj prejema posodobitve napredka):**

```python
# From client/client.py - Client handling real-time notifications
async def message_handler(message) -> None:
    if isinstance(message, types.ServerNotification):
        if isinstance(message.root, types.LoggingMessageNotification):
            console.print(f"üì° [dim]{message.root.params.data}[/dim]")
        elif isinstance(message.root, types.ProgressNotification):
            progress = message.root.params
            console.print(f"üîÑ [yellow]{progress.message} ({progress.progress}/{progress.total})[/yellow]")

# Register message handler when creating session
async with ClientSession(
    read_stream, write_stream,
    message_handler=message_handler
) as session:
```

#### Elicitation - Zahteva za uporabni≈°ki vnos

Elicitation omogoƒça agentom, da med izvajanjem zahtevajo uporabni≈°ki vnos. To je bistveno za potrditve, pojasnila ali odobritve med dolgotrajnimi nalogami.

**Implementacija na stre≈æniku (agent zahteva potrditev):**

```python
# From server/server.py - Travel agent requesting price confirmation
elicit_result = await ctx.session.elicit(
    message=f"Please confirm the estimated price of $1200 for your trip to {destination}",
    requestedSchema=PriceConfirmationSchema.model_json_schema(),
    related_request_id=ctx.request_id,
)

if elicit_result and elicit_result.action == "accept":
    # Continue with booking
    logger.info(f"User confirmed price: {elicit_result.content}")
elif elicit_result and elicit_result.action == "decline":
    # Cancel the booking
    booking_cancelled = True
```

**Implementacija na odjemalcu (gostitelj zagotavlja povratni klic za elicitation):**

```python
# From client/client.py - Client handling elicitation requests
async def elicitation_callback(context, params):
    console.print(f"üí¨ Server is asking for confirmation:")
    console.print(f"   {params.message}")

    response = console.input("Do you accept? (y/n): ").strip().lower()

    if response in ['y', 'yes']:
        return types.ElicitResult(
            action="accept",
            content={"confirm": True, "notes": "Confirmed by user"}
        )
    else:
        return types.ElicitResult(
            action="decline",
            content={"confirm": False, "notes": "Declined by user"}
        )

# Register the callback when creating the session
async with ClientSession(
    read_stream, write_stream,
    elicitation_callback=elicitation_callback
) as session:
```

#### Sampling - Zahteva za AI pomoƒç

Sampling omogoƒça agentom, da med izvajanjem zahtevajo pomoƒç LLM za kompleksne odloƒçitve ali generiranje vsebine. To omogoƒça hibridne delovne tokove ƒçlovek-AI.

**Implementacija na stre≈æniku (agent zahteva AI pomoƒç):**

```python
# From server/server.py - Research agent requesting AI summary
sampling_result = await ctx.session.create_message(
    messages=[
        SamplingMessage(
            role="user",
            content=TextContent(type="text", text=f"Please summarize the key findings for research on: {topic}")
        )
    ],
    max_tokens=100,
    related_request_id=ctx.request_id,
)

if sampling_result and sampling_result.content:
    if sampling_result.content.type == "text":
        sampling_summary = sampling_result.content.text
        logger.info(f"Received sampling summary: {sampling_summary}")
```

**Implementacija na odjemalcu (gostitelj zagotavlja povratni klic za sampling):**

```python
# From client/client.py - Client handling sampling requests
async def sampling_callback(context, params):
    message_text = params.messages[0].content.text if params.messages else 'No message'
    console.print(f"üß† Server requested sampling: {message_text}")

    # In a real application, this could call an LLM API
    # For demo purposes, we provide a mock response
    mock_response = "Based on current research, MCP has evolved significantly..."

    return types.CreateMessageResult(
        role="assistant",
        content=types.TextContent(type="text", text=mock_response),
        model="interactive-client",
        stopReason="endTurn"
    )

# Register the callback when creating the session
async with ClientSession(
    read_stream, write_stream,
    sampling_callback=sampling_callback,
    elicitation_callback=elicitation_callback
) as session:
```

#### Ponovna vzpostavitev - Kontinuiteta sej ob prekinitvah

Ponovna vzpostavitev zagotavlja, da dolgotrajne naloge agentov pre≈æivijo prekinitve odjemalca in se brezhibno nadaljujejo ob ponovni povezavi. To je implementirano prek shranjevanja dogodkov in ≈æetonov za ponovno vzpostavitev.

**Implementacija shranjevanja dogodkov (stre≈ænik hrani stanje seje):**

```python
# From server/event_store.py - Simple in-memory event store
class SimpleEventStore(EventStore):
    def __init__(self):
        self._events: list[tuple[StreamId, EventId, JSONRPCMessage]] = []
        self._event_id_counter = 0

    async def store_event(self, stream_id: StreamId, message: JSONRPCMessage) -> EventId:
        """Store an event and return its ID."""
        self._event_id_counter += 1
        event_id = str(self._event_id_counter)
        self._events.append((stream_id, event_id, message))
        return event_id

    async def replay_events_after(self, last_event_id: EventId, send_callback: EventCallback) -> StreamId | None:
        """Replay events after the specified ID for resumption."""
        # Find events after the last known event and replay them
        for _, event_id, message in self._events[start_index:]:
            await send_callback(EventMessage(message, event_id))

# From server/server.py - Passing event store to session manager
def create_server_app(event_store: Optional[EventStore] = None) -> Starlette:
    server = ResumableServer()

    # Create session manager with event store for resumption
    session_manager = StreamableHTTPSessionManager(
        app=server,
        event_store=event_store,  # Event store enables session resumption
        json_response=False,
        security_settings=security_settings,
    )

    return Starlette(routes=[Mount("/mcp", app=session_manager.handle_request)])

# Usage: Initialize with event store
event_store = SimpleEventStore()
app = create_server_app(event_store)
```

**Metapodatki odjemalca z ≈æetonom za ponovno vzpostavitev (odjemalec se ponovno pove≈æe z uporabo shranjenega stanja):**

```python
# From client/client.py - Client resumption with metadata
if existing_tokens and existing_tokens.get("resumption_token"):
    # Use existing resumption token to continue where we left off
    metadata = ClientMessageMetadata(
        resumption_token=existing_tokens["resumption_token"],
    )
else:
    # Create callback to save resumption token when received
    def enhanced_callback(token: str):
        protocol_version = getattr(session, 'protocol_version', None)
        token_manager.save_tokens(session_id, token, protocol_version, command, args)

    metadata = ClientMessageMetadata(
        on_resumption_token_update=enhanced_callback,
    )

# Send request with resumption metadata
result = await session.send_request(
    types.ClientRequest(
        types.CallToolRequest(
            method="tools/call",
            params=types.CallToolRequestParams(name=command, arguments=args)
        )
    ),
    types.CallToolResult,
    metadata=metadata,
)
```

Gostiteljska aplikacija lokalno hrani ID-je sej in ≈æetone za ponovno vzpostavitev, kar ji omogoƒça ponovno povezavo z obstojeƒçimi sejami brez izgube napredka ali stanja.

### Organizacija kode

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>Slika 5:</strong> Arhitektura sistema agentov na osnovi MCP
</div>

```mermaid
graph LR
    User([User]) -->|"Task"| Host["Host<br/>(MCP Client)"]
    Host -->|list tools| Server[MCP Server]
    Server -->|Exposes| AgentsTools[Agents as Tools]
    AgentsTools -->|Task| AgentA[Travel Agent]
    AgentsTools -->|Task| AgentB[Research Agent]

    Host -->|Monitors| StateUpdates[Progress & State Updates]
    Server -->|Publishes| StateUpdates

    class User user;
    class AgentA,AgentB agent;
    class Host,Server,StateUpdates core;
```

**Kljuƒçne datoteke:**

- **`server/server.py`** - Ponovno vzpostavljiv MCP stre≈ænik z agentoma za potovanja in raziskave, ki prikazujeta elicitation, sampling in posodobitve napredka
- **`client/client.py`** - Interaktivna gostiteljska aplikacija s podporo za ponovno vzpostavitev, povratnimi klici in upravljanjem ≈æetonov
- **`server/event_store.py`** - Implementacija shranjevanja dogodkov, ki omogoƒça ponovno vzpostavitev sej in ponovno dostavo sporoƒçil

## Raz≈°iritev na komunikacijo med veƒç agenti na MCP

Zgornjo implementacijo je mogoƒçe raz≈°iriti na sisteme z veƒç agenti z izbolj≈°anjem inteligence in obsega gostiteljske aplikacije:

- **Inteligentna razƒçlenitev nalog**: Gostitelj analizira kompleksne uporabni≈°ke zahteve in jih razdeli na podnaloge za razliƒçne specializirane agente
- **Koordinacija veƒç stre≈ænikov**: Gostitelj vzdr≈æuje povezave z veƒç MCP stre≈æniki, od katerih vsak ponuja razliƒçne zmogljivosti agentov
- **Upravljanje stanja nalog**: Gostitelj sledi napredku veƒç soƒçasnih nalog agentov, obravnava odvisnosti in zaporedja
- **Odpornost in ponovitve**: Gostitelj upravlja napake, implementira logiko ponovitev in preusmerja naloge, ko agenti postanejo nedosegljivi
- **Sinteza rezultatov**: Gostitelj zdru≈æuje rezultate veƒç agentov v koherentne konƒçne rezultate

Gostitelj se razvije iz preprostega odjemalca v inteligentnega orkestratorja, ki koordinira zmogljivosti razpr≈°enih agentov, hkrati pa ohranja isto osnovo MCP protokola.

## Zakljuƒçek

Izbolj≈°ane zmogljivosti MCP - obvestila o virih, elicitation/sampling, ponovno vzpostavljivi tokovi in trajni viri - omogoƒçajo kompleksne interakcije med agenti, hkrati pa ohranjajo preprostost protokola.

## Zaƒçetek

Pripravljeni na gradnjo lastnega sistema agent2agent? Sledite tem korakom:

### 1. Za≈æenite demo

```bash
# Start the server with event store for resumption
python -m server.server --port 8006

# In another terminal, run the interactive client
python -m client.client --url http://127.0.0.1:8006/mcp
```

**Razpolo≈æljivi ukazi v interaktivnem naƒçinu:**

- `travel_agent` - Rezervirajte potovanje s potrditvijo cene prek elicitation
- `research_agent` - Raziskujte teme s povzetki, ki jih omogoƒça AI, prek sampling
- `list` - Prika≈æi vsa razpolo≈æljiva orodja
- `clean-tokens` - Poƒçisti ≈æetone za ponovno vzpostavitev
- `help` - Prika≈æi podrobno pomoƒç za ukaze
- `quit` - Izhod iz odjemalca

### 2. Preizkusite zmogljivosti ponovne vzpostavitve

- Za≈æenite dolgotrajnega agenta (npr. `travel_agent`)
- Prekinite odjemalca med izvajanjem (Ctrl+C)
- Ponovno za≈æenite odjemalca - samodejno bo nadaljeval tam, kjer je konƒçal

### 3. Raziskujte in raz≈°irjajte

- **Raziskujte primere**: Oglejte si ta [mcp-agents](

---

**Omejitev odgovornosti**:  
Ta dokument je bil preveden z uporabo storitve za prevajanje z umetno inteligenco [Co-op Translator](https://github.com/Azure/co-op-translator). ƒåeprav si prizadevamo za natanƒçnost, vas prosimo, da upo≈°tevate, da lahko avtomatizirani prevodi vsebujejo napake ali netoƒçnosti. Izvirni dokument v njegovem izvirnem jeziku je treba obravnavati kot avtoritativni vir. Za kljuƒçne informacije priporoƒçamo profesionalni ƒçlove≈°ki prevod. Ne prevzemamo odgovornosti za morebitna nesporazumevanja ali napaƒçne razlage, ki bi nastale zaradi uporabe tega prevoda.