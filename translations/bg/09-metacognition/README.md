<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f0deef171fc3a68d5d3d770a8bfb03d",
  "translation_date": "2025-08-29T21:00:41+00:00",
  "source_file": "09-metacognition/README.md",
  "language_code": "bg"
}
-->
[![Многопотребителски дизайн](../../../translated_images/lesson-9-thumbnail.38059e8af1a5b71d890c92f576f933c6a307c691339dca7e8ca6ea75a8d857a1.bg.png)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Кликнете върху изображението по-горе, за да гледате видеото на този урок)_
# Метакогниция в AI агенти

## Въведение

Добре дошли в урока за метакогниция в AI агенти! Тази глава е предназначена за начинаещи, които се интересуват от това как AI агентите могат да разсъждават върху собствените си мисловни процеси. До края на този урок ще разберете ключови концепции и ще имате практически примери за прилагане на метакогниция в дизайна на AI агенти.

## Цели на обучението

След завършване на този урок ще можете:

1. Да разберете последиците от цикли на разсъждение в дефинициите на агенти.
2. Да използвате техники за планиране и оценка, за да подпомогнете само-коригиращи се агенти.
3. Да създавате свои собствени агенти, способни да манипулират код за изпълнение на задачи.

## Въведение в метакогницията

Метакогницията се отнася до по-висши когнитивни процеси, които включват мислене за собственото мислене. За AI агентите това означава способност да оценяват и коригират действията си въз основа на самосъзнание и минал опит. Метакогницията, или "мислене за мисленето", е важна концепция в развитието на агентни AI системи. Тя включва осъзнаване на вътрешните процеси и способност за наблюдение, регулиране и адаптиране на поведението. Подобно на това, което правим, когато анализираме ситуация или решаваме проблем. Това самосъзнание може да помогне на AI системите да вземат по-добри решения, да идентифицират грешки и да подобряват представянето си с времето – отново свързвайки се с теста на Тюринг и дебата дали AI ще поеме контрола.

В контекста на агентни AI системи метакогницията може да помогне за справяне с няколко предизвикателства, като:
- Прозрачност: Осигуряване, че AI системите могат да обясняват своите разсъждения и решения.
- Разсъждение: Подобряване на способността на AI системите да синтезират информация и да вземат обосновани решения.
- Адаптация: Позволяване на AI системите да се приспособяват към нови среди и променящи се условия.
- Възприятие: Подобряване на точността на AI системите при разпознаване и интерпретиране на данни от тяхната среда.

### Какво е метакогниция?

Метакогницията, или "мислене за мисленето", е по-висш когнитивен процес, който включва самосъзнание и саморегулация на когнитивните процеси. В сферата на AI метакогницията дава възможност на агентите да оценяват и адаптират своите стратегии и действия, водейки до подобрени способности за решаване на проблеми и вземане на решения. Чрез разбирането на метакогницията можете да проектирате AI агенти, които са не само по-интелигентни, но и по-адаптивни и ефективни. В истинската метакогниция AI би разсъждавал изрично за собствените си разсъждения.

Пример: „Приоритизирах по-евтини полети, защото... Може би пропускам директни полети, затова нека проверя отново.“
Проследяване на това как или защо е избрал определен маршрут.
- Забелязване, че е направил грешки, защото е разчитал прекалено на предпочитанията на потребителя от предишния път, и модифициране на стратегията си за вземане на решения, а не само на крайната препоръка.
- Диагностициране на модели като: „Всеки път, когато потребителят спомене „прекалено претъпкано“, трябва не само да премахна определени атракции, но и да осъзная, че методът ми за избор на „топ атракции“ е погрешен, ако винаги класирам по популярност.“

### Значение на метакогницията в AI агентите

Метакогницията играе ключова роля в дизайна на AI агенти по няколко причини:

![Значение на метакогницията](../../../translated_images/importance-of-metacognition.b381afe9aae352f7734c8628ea3f4b23084634b791c5a120c76a02bb7eeeb7ec.bg.png)

- Самоанализ: Агенти могат да оценяват собственото си представяне и да идентифицират области за подобрение.
- Адаптивност: Агенти могат да модифицират стратегиите си въз основа на минал опит и променящи се условия.
- Корекция на грешки: Агенти могат да откриват и коригират грешки автономно, водейки до по-точни резултати.
- Управление на ресурси: Агенти могат да оптимизират използването на ресурси, като време и изчислителна мощност, чрез планиране и оценка на действията си.

## Компоненти на AI агент

Преди да се потопим в метакогнитивните процеси, е важно да разберем основните компоненти на AI агент. Обикновено AI агентът се състои от:

- Персона: Личността и характеристиките на агента, които определят как той взаимодейства с потребителите.
- Инструменти: Способностите и функциите, които агентът може да изпълнява.
- Умения: Знанията и експертизата, които агентът притежава.

Тези компоненти работят заедно, за да създадат "единица на експертиза", която може да изпълнява специфични задачи.

**Пример**:
Представете си туристически агент, който не само планира вашата почивка, но и коригира маршрута си въз основа на данни в реално време и предишен опит с клиентски пътувания.

### Пример: Метакогниция в услуга за туристически агент

Представете си, че проектирате услуга за туристически агент, задвижвана от AI. Този агент, "Туристически агент", помага на потребителите да планират своите ваканции. За да включите метакогниция, Туристическият агент трябва да оценява и коригира действията си въз основа на самосъзнание и минал опит. Ето как метакогницията може да играе роля:

#### Текуща задача

Текущата задача е да помогне на потребител да планира пътуване до Париж.

#### Стъпки за изпълнение на задачата

1. **Събиране на предпочитания на потребителя**: Попитайте потребителя за дати на пътуване, бюджет, интереси (напр. музеи, кухня, пазаруване) и специфични изисквания.
2. **Извличане на информация**: Търсете опции за полети, настаняване, атракции и ресторанти, които отговарят на предпочитанията на потребителя.
3. **Генериране на препоръки**: Осигурете персонализиран маршрут с детайли за полети, хотелски резервации и предложени дейности.
4. **Корекция въз основа на обратна връзка**: Попитайте потребителя за обратна връзка относно препоръките и направете необходимите корекции.

#### Необходими ресурси

- Достъп до бази данни за резервации на полети и хотели.
- Информация за атракции и ресторанти в Париж.
- Данни за обратна връзка от предишни взаимодействия.

#### Опит и самоанализ

Туристическият агент използва метакогниция, за да оцени представянето си и да се учи от минал опит. Например:

1. **Анализ на обратната връзка от потребителя**: Туристическият агент преглежда обратната връзка, за да определи кои препоръки са били добре приети и кои не. Той коригира бъдещите си предложения съответно.
2. **Адаптивност**: Ако потребителят преди е споменал, че не харесва претъпкани места, Туристическият агент ще избягва да препоръчва популярни туристически обекти в пикови часове в бъдеще.
3. **Корекция на грешки**: Ако Туристическият агент е направил грешка в предишна резервация, като например предложил хотел, който е бил напълно резервиран, той се учи да проверява наличността по-стриктно преди да прави препоръки.

#### Практически пример за разработчици

Ето опростен пример за това как кодът на Туристическия агент може да изглежда при включване на метакогниция:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Search for flights, hotels, and attractions based on preferences
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Analyze feedback and adjust future recommendations
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Защо метакогницията е важна

- **Самоанализ**: Агенти могат да анализират представянето си и да идентифицират области за подобрение.
- **Адаптивност**: Агенти могат да модифицират стратегии въз основа на обратна връзка и променящи се условия.
- **Корекция на грешки**: Агенти могат автономно да откриват и коригират грешки.
- **Управление на ресурси**: Агенти могат да оптимизират използването на ресурси, като време и изчислителна мощност.

Чрез включване на метакогниция Туристическият агент може да предоставя по-персонализирани и точни препоръки за пътуване, подобрявайки цялостното потребителско изживяване.

---

## 2. Планиране в агенти

Планирането е критичен компонент на поведението на AI агентите. То включва очертаване на стъпките, необходими за постигане на цел, като се вземат предвид текущото състояние, ресурсите и възможните препятствия.

### Елементи на планирането

- **Текуща задача**: Ясно дефинирайте задачата.
- **Стъпки за изпълнение на задачата**: Разделете задачата на управляеми стъпки.
- **Необходими ресурси**: Идентифицирайте необходимите ресурси.
- **Опит**: Използвайте минал опит, за да информирате планирането.

**Пример**:
Ето стъпките, които Туристическият агент трябва да предприеме, за да помогне на потребител при планиране на пътуване ефективно:

### Стъпки за Туристическия агент

1. **Събиране на предпочитания на потребителя**
   - Попитайте потребителя за подробности относно датите на пътуване, бюджета, интересите и специфичните изисквания.
   - Примери: "Кога планирате да пътувате?" "Какъв е вашият бюджет?" "Какви дейности обичате по време на ваканция?"

2. **Извличане на информация**
   - Търсете подходящи опции за пътуване въз основа на предпочитанията на потребителя.
   - **Полети**: Потърсете налични полети в рамките на бюджета и предпочитаните дати на пътуване.
   - **Настаняване**: Намерете хотели или наемни имоти, които отговарят на предпочитанията на потребителя за местоположение, цена и удобства.
   - **Атракции и ресторанти**: Идентифицирайте популярни атракции, дейности и възможности за хранене, които съответстват на интересите на потребителя.

3. **Генериране на препоръки**
   - Компилирайте извлечената информация в персонализиран маршрут.
   - Осигурете детайли като опции за полети, хотелски резервации и предложени дейности, като се уверите, че препоръките са съобразени с предпочитанията на потребителя.

4. **Представяне на маршрута на потребителя**
   - Споделете предложения маршрут с потребителя за преглед.
   - Пример: "Ето предложен маршрут за вашето пътуване до Париж. Той включва детайли за полети, хотелски резервации и списък с препоръчани дейности и ресторанти. Кажете ми вашето мнение!"

5. **Събиране на обратна връзка**
   - Попитайте потребителя за обратна връзка относно предложения маршрут.
   - Примери: "Харесват ли ви опциите за полети?" "Хотелът подходящ ли е за вашите нужди?" "Има ли дейности, които бихте искали да добавите или премахнете?"

6. **Корекция въз основа на обратна връзка**
   - Модифицирайте маршрута въз основа на обратната връзка на потребителя.
   - Направете необходимите промени в препоръките за полети, настаняване и дейности, за да отговарят по-добре на предпочитанията на потребителя.

7. **Финално потвърждение**
   - Представете актуализирания маршрут на потребителя за финално потвърждение.
   - Пример: "Направих корекциите въз основа на вашата обратна връзка. Ето актуализирания маршрут. Всичко ли изглежда добре за вас?"

8. **Резервация и потвърждение**
   - След като потребителят одобри маршрута, продължете с резервацията на полети, настаняване и предварително планирани дейности.
   - Изпратете детайли за потвърждение на потребителя.

9. **Осигуряване на текуща поддръжка**
   - Останете на разположение, за да помогнете на потребителя с всякакви промени или допълнителни заявки преди и по време на пътуването.
   - Пример: "Ако имате нужда от допълнителна помощ по време на пътуването си, не се колебайте да се свържете с мен по всяко време!"

### Пример за взаимодействие

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage within a booing request
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Корективна RAG система

Първо, нека започнем с разбирането на разликата между RAG инструмент и предварително зареждане на контекст.

![RAG срещу зареждане на контекст](../../../translated_images/rag-vs-context.9eae588520c00921f531e4dc788992e8a7b69b6ff7c9eaa69fb9bc83ad243504.bg.png)

### Извличане-усилено генериране (RAG)

RAG комбинира система за извличане с генеративен модел. Когато се направи заявка, системата за извличане извлича релевантни документи или данни от външен източник, и тази извлечена информация се използва за усилване на входа към генеративния модел. Това помага на модела да генерира по-точни и контекстуално релевантни отговори.

В RAG система агентът извлича релевантна информация от база знания и я използва, за да генерира подходящи отговори или действия.

### Корективен подход на RAG

Корективният подход на RAG се фокусира върху използването на RAG техники за коригиране на грешки и подобряване на точността на AI агентите. Това включва:

1. **Техника на подканване**: Използване на специфични подканвания за насочване на агента при извличане на релевантна информация.
2. **Инструмент**: Прилагане на алгоритми и механизми, които позволяват на агента да оценява релевантността на извлечената информация и да генерира точни отговори.
3. **Оценка**: Непрекъснато оценяване на представянето на агента и правене на корекции за подобряване на точността и ефективността.

#### Пример: Корективен RAG в търсещ агент

Представете си търсещ агент, който извлича информация от интернет, за да отговаря на потребителски запитвания. Корективният подход на RAG може да включва:

1. **Техника на подканване**: Формулиране на търсещи запитвания въз основа на входа на потребителя.
2. **Инструмент**: Използване на алгоритми за обработка на естествен език и машинно обучение за класиране и филтриране на резултатите от търсенето.
3. **Оценка**: Анализиране на обратната връзка от потребителя за идентифициране и коригиране на неточности в извлечената информация.

### Корективен RAG в Туристически агент

Корективният RAG (Извличане-ус
```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Предварително зареждане на контекст

Предварителното зареждане на контекст включва зареждане на подходяща информация или фонова информация в модела преди обработката на заявка. Това означава, че моделът има достъп до тази информация от самото начало, което му помага да генерира по-информирани отговори, без да се налага да извлича допълнителни данни по време на процеса.

Ето един опростен пример за предварително зареждане на контекст за приложение на туристически агент на Python:

```python
class TravelAgent:
    def __init__(self):
        # Pre-load popular destinations and their information
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Fetch destination information from pre-loaded context
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Example usage
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Обяснение

1. **Инициализация (`__init__` метод)**: Класът `TravelAgent` предварително зарежда речник, съдържащ информация за популярни дестинации като Париж, Токио, Ню Йорк и Сидни. Този речник включва подробности като държава, валута, език и основни атракции за всяка дестинация.

2. **Извличане на информация (`get_destination_info` метод)**: Когато потребителят направи запитване за конкретна дестинация, методът `get_destination_info` извлича съответната информация от предварително заредения контекстен речник.

Чрез предварително зареждане на контекста, приложението на туристическия агент може бързо да отговаря на запитванията на потребителите, без да се налага да извлича тази информация от външен източник в реално време. Това прави приложението по-ефективно и отзивчиво.

### Стартиране на плана с цел преди итерация

Стартирането на план с ясна цел включва започване с предварително дефинирана цел или желан резултат. Чрез определяне на тази цел предварително, моделът може да я използва като водещ принцип през целия итеративен процес. Това помага да се гарантира, че всяка итерация се приближава към постигането на желания резултат, правейки процеса по-ефективен и фокусиран.

Ето пример за това как може да се стартира план за пътуване с цел преди итерация за туристически агент на Python:

### Сценарий

Туристически агент иска да планира персонализирана ваканция за клиент. Целта е да се създаде туристически маршрут, който максимално удовлетворява клиента въз основа на неговите предпочитания и бюджет.

### Стъпки

1. Определете предпочитанията и бюджета на клиента.
2. Стартирайте началния план въз основа на тези предпочитания.
3. Итеративно усъвършенствайте плана, оптимизирайки го за удовлетворението на клиента.

#### Python код

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Example usage
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Обяснение на кода

1. **Инициализация (`__init__` метод)**: Класът `TravelAgent` се инициализира със списък от потенциални дестинации, всяка с атрибути като име, цена и тип дейност.

2. **Стартиране на плана (`bootstrap_plan` метод)**: Този метод създава начален план за пътуване въз основа на предпочитанията и бюджета на клиента. Той преминава през списъка с дестинации и ги добавя към плана, ако отговарят на предпочитанията на клиента и се вписват в бюджета.

3. **Съответствие с предпочитанията (`match_preferences` метод)**: Този метод проверява дали дадена дестинация отговаря на предпочитанията на клиента.

4. **Итерация на плана (`iterate_plan` метод)**: Този метод усъвършенства началния план, като се опитва да замени всяка дестинация в плана с по-добро съответствие, като се вземат предвид предпочитанията и бюджетните ограничения на клиента.

5. **Изчисляване на разходите (`calculate_cost` метод)**: Този метод изчислява общите разходи за текущия план, включително потенциална нова дестинация.

#### Пример за използване

- **Начален план**: Туристическият агент създава начален план въз основа на предпочитанията на клиента за разглеждане на забележителности и бюджет от $2000.
- **Усъвършенстван план**: Туристическият агент итеративно усъвършенства плана, оптимизирайки го спрямо предпочитанията и бюджета на клиента.

Чрез стартиране на плана с ясна цел (например максимално удовлетворение на клиента) и итеративно усъвършенстване на плана, туристическият агент може да създаде персонализиран и оптимизиран туристически маршрут за клиента. Този подход гарантира, че планът за пътуване отговаря на предпочитанията и бюджета на клиента от самото начало и се подобрява с всяка итерация.

### Използване на LLM за преоценка и оценяване

Големите езикови модели (LLMs) могат да се използват за преоценка и оценяване, като оценяват релевантността и качеството на извлечените документи или генерираните отговори. Ето как работи:

**Извличане:** Първоначалната стъпка за извличане събира набор от кандидат-документи или отговори въз основа на заявката.

**Преоценка:** LLM оценява тези кандидати и ги преоценява въз основа на тяхната релевантност и качество. Тази стъпка гарантира, че най-релевантната и качествена информация се представя първа.

**Оценяване:** LLM присвоява оценки на всеки кандидат, отразяващи тяхната релевантност и качество. Това помага при избора на най-добрия отговор или документ за потребителя.

Чрез използване на LLM за преоценка и оценяване, системата може да предостави по-точна и контекстуално релевантна информация, подобрявайки цялостното потребителско изживяване.

Ето пример за това как туристически агент може да използва голям езиков модел (LLM) за преоценка и оценяване на туристически дестинации въз основа на предпочитанията на потребителя на Python:

#### Сценарий - Пътуване според предпочитанията

Туристически агент иска да препоръча най-добрите туристически дестинации на клиент въз основа на неговите предпочитания. LLM ще помогне за преоценка и оценяване на дестинациите, за да гарантира, че най-релевантните опции се представят.

#### Стъпки:

1. Съберете предпочитанията на потребителя.
2. Извлечете списък с потенциални туристически дестинации.
3. Използвайте LLM за преоценка и оценяване на дестинациите въз основа на предпочитанията на потребителя.

Ето как можете да актуализирате предишния пример, за да използвате Azure OpenAI Services:

#### Изисквания

1. Трябва да имате абонамент за Azure.
2. Създайте ресурс Azure OpenAI и вземете вашия API ключ.

#### Примерен Python код

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Generate a prompt for the Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Define headers and payload for the request
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Call the Azure OpenAI API to get the re-ranked and scored destinations
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Extract and return the recommendations
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Example usage
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Обяснение на кода - Препоръчател на предпочитания

1. **Инициализация**: Класът `TravelAgent` се инициализира със списък от потенциални туристически дестинации, всяка с атрибути като име и описание.

2. **Получаване на препоръки (`get_recommendations` метод)**: Този метод генерира подканващ текст за услугата Azure OpenAI въз основа на предпочитанията на потребителя и прави HTTP POST заявка към API на Azure OpenAI, за да получи преоценени и оценени дестинации.

3. **Генериране на подканващ текст (`generate_prompt` метод)**: Този метод създава подканващ текст за Azure OpenAI, включващ предпочитанията на потребителя и списъка с дестинации. Подканващият текст насочва модела да преоцени и оцени дестинациите въз основа на предоставените предпочитания.

4. **API заявка**: Библиотеката `requests` се използва за извършване на HTTP POST заявка към крайна точка на API на Azure OpenAI. Отговорът съдържа преоценените и оценени дестинации.

5. **Пример за използване**: Туристическият агент събира предпочитанията на потребителя (например интерес към разглеждане на забележителности и разнообразна култура) и използва услугата Azure OpenAI, за да получи преоценени и оценени препоръки за туристически дестинации.

Уверете се, че заменяте `your_azure_openai_api_key` с вашия действителен API ключ за Azure OpenAI и `https://your-endpoint.com/...` с действителния URL адрес на крайна точка на вашето разгръщане на Azure OpenAI.

Чрез използване на LLM за преоценка и оценяване, туристическият агент може да предостави по-персонализирани и релевантни препоръки за пътуване на клиентите, подобрявайки тяхното цялостно изживяване.

### RAG: Техника за подканване срещу инструмент

Извличане-усилено генериране (RAG) може да бъде както техника за подканване, така и инструмент в разработката на AI агенти. Разбирането на разликата между двете може да ви помогне да използвате RAG по-ефективно във вашите проекти.

#### RAG като техника за подканване

**Какво е това?**

- Като техника за подканване, RAG включва формулиране на специфични запитвания или подканващи текстове за насочване на извличането на релевантна информация от голям корпус или база данни. Тази информация след това се използва за генериране на отговори или действия.

**Как работи:**

1. **Формулиране на подканващи текстове**: Създайте добре структурирани подканващи текстове или запитвания въз основа на задачата или входа на потребителя.
2. **Извличане на информация**: Използвайте подканващите текстове за търсене на релевантни данни от предварително съществуваща база знания или набор от данни.
3. **Генериране на отговор**: Комбинирайте извлечената информация с генеративни AI модели, за да създадете изчерпателен и последователен отговор.

**Пример в туристически агент**:

- Вход на потребителя: "Искам да посетя музеи в Париж."
- Подканващ текст: "Намерете най-добрите музеи в Париж."
- Извлечена информация: Подробности за Лувъра, Музея Орсе и др.
- Генериран отговор: "Ето някои от най-добрите музеи в Париж: Лувър, Музей Орсе и Център Помпиду."

#### RAG като инструмент

**Какво е това?**

- Като инструмент, RAG е интегрирана система, която автоматизира процеса на извличане и генериране, улеснявайки разработчиците да внедряват сложни AI функционалности без ръчно създаване на подканващи текстове за всяко запитване.

**Как работи:**

1. **Интеграция**: Вградете RAG в архитектурата на AI агента, позволявайки му автоматично да се справя с задачите за извличане и генериране.
2. **Автоматизация**: Инструментът управлява целия процес, от получаване на входа на потребителя до генериране на крайния отговор, без да изисква явни подканващи текстове за всяка стъпка.
3. **Ефективност**: Подобрява производителността на агента, като рационализира процеса на извличане и генериране, позволявайки по-бързи и точни отговори.

**Пример в туристически агент**:

- Вход на потребителя: "Искам да посетя музеи в Париж."
- RAG инструмент: Автоматично извлича информация за музеи и генерира отговор.
- Генериран отговор: "Ето някои от най-добрите музеи в Париж: Лувър, Музей Орсе и Център Помпиду."

### Сравнение

| Аспект                 | Техника за подканване                                        | Инструмент                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Ръчно срещу автоматично**| Ръчно формулиране на подканващи текстове за всяко запитване.               | Автоматизиран процес за извличане и генериране.       |
| **Контрол**            | Предоставя повече контрол върху процеса на извличане.             | Рационализира и автоматизира извличането и генерирането.|
| **Гъвкавост**        | Позволява персонализирани подканващи текстове въз основа на специфични нужди.      | По-ефективен за мащабни внедрения.       |
| **Сложност**         | Изисква създаване и настройка на подканващи текстове.                  | По-лесен за интеграция в архитектурата на AI агента. |

### Практически примери

**Пример за техника за подканване:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Пример за инструмент:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Оценка на релевантността

Оценката на релевантността е ключов аспект от производителността на AI агентите. Тя гарантира, че информацията, извлечена и генерирана от агента, е подходяща, точна и полезна за потребителя. Нека разгледаме как да оценяваме релевантността в AI агенти, включително практически примери и техники.

#### Основни концепции в оценката на релевантността

1. **Осъзнаване на контекста**:
   - Агенцията трябва да разбира контекста на запитването на потребителя, за да извлича и генерира релевантна информация.
   - Пример: Ако потребителят пита за "най-добрите ресторанти в Париж", агентът трябва да вземе предвид предпочитанията на потребителя, като тип кухня и бюджет.

2. **Точност**:
   - Информацията, предоставена от агента, трябва да бъде фактически вярна и актуална.
   - Пример: Препоръчване на ресторанти, които са отворени и имат добри отзиви, вместо остарели или затворени опции.

3. **Намерение на потребителя**:
   - Агенцията трябва да извлече намерението на потребителя зад запитването, за да предостави най-релевантната информация.
   - Пример: Ако потребителят пита за "евтини хотели", агентът трябва да приоритизира достъпни опции.

4. **Обратна връзка**:
   - Непрекъснатото събиране и анализиране на обратна връзка от потребителите помага на агента да усъвършенства процеса на оценка на релевантността.
   - Пример: Включване на оценки и обратна връзка от потребителите за предишни препоръки за подобряване на бъдещите отговори.

#### Практически техники за оценка на релевантността

1. **Оценяване на релевантността**:
   - Присвояване на оценка за релевантност на всеки извлечен елемент въз основа на това колко добре съответства на запитването и предпочитанията на потребителя.
   - Пример:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Филтриране и класиране**:
   - Филтриране на нерелевантни елементи и класиране на останалите въз основа на техните оценки за релевантност.
   - Пример:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Return top 10 relevant items
     ```

3. **Обработка на естествен език (NLP)**:
   - Използване на NLP техники за разбиране на запитването на потребителя и извличане на релевантна информация.
   - Пример:

     ```python
     def process_query(query):
         # Use NLP to extract key information from the user's query
         processed_query = nlp(query)
         return processed_query
     ```

4. **Интеграция на обратна връзка от потребителя**:
   - Събиране на обратна връзка от потребителите за предоставените препоръки и използването й за коригиране на бъдещите оценки за релевантност.
   - Пример:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Пример: Оценка на релевантността в туристически агент

Ето практически пример за това как туристически агент може да оцени релевантността на туристическите препоръки:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Return top 10 relevant items

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Търсене с намерение

Търсенето с намерение включва разбиране и интерпретиране на основната цел или цел зад запитването на потребителя, за да се извлече и генерира най-релевантната и
#### Практически пример: Търсене с намерение в Travel Agent

Нека вземем Travel Agent като пример, за да видим как може да се приложи търсенето с намерение.

1. **Събиране на предпочитанията на потребителя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Разбиране на намерението на потребителя**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Осъзнаване на контекста**

   ```python
   def analyze_context(query, user_history):
       # Combine current query with user history to understand context
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Търсене и персонализиране на резултатите**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Example search logic for informational intent
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Example search logic for navigational intent
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Example search logic for transactional intent
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Example personalization logic
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Return top 10 personalized results
   ```

5. **Пример за използване**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Генериране на код като инструмент

Агентите за генериране на код използват AI модели, за да пишат и изпълняват код, решавайки сложни проблеми и автоматизирайки задачи.

### Агентите за генериране на код

Агентите за генериране на код използват генеративни AI модели, за да пишат и изпълняват код. Те могат да решават сложни проблеми, да автоматизират задачи и да предоставят ценни прозрения, като генерират и изпълняват код на различни програмни езици.

#### Практически приложения

1. **Автоматизирано генериране на код**: Генериране на кодови фрагменти за конкретни задачи, като анализ на данни, уеб скрейпинг или машинно обучение.
2. **SQL като RAG**: Използване на SQL заявки за извличане и манипулиране на данни от бази данни.
3. **Решаване на проблеми**: Създаване и изпълнение на код за решаване на специфични проблеми, като оптимизиране на алгоритми или анализ на данни.

#### Пример: Агент за генериране на код за анализ на данни

Представете си, че проектирате агент за генериране на код. Ето как може да работи:

1. **Задача**: Анализ на набор от данни за идентифициране на тенденции и модели.
2. **Стъпки**:
   - Зареждане на набора от данни в инструмент за анализ на данни.
   - Генериране на SQL заявки за филтриране и агрегиране на данните.
   - Изпълнение на заявките и извличане на резултатите.
   - Използване на резултатите за създаване на визуализации и прозрения.
3. **Необходими ресурси**: Достъп до набора от данни, инструменти за анализ на данни и SQL възможности.
4. **Опит**: Използване на предишни резултати от анализи за подобряване на точността и релевантността на бъдещите анализи.

### Пример: Агент за генериране на код за Travel Agent

В този пример ще проектираме агент за генериране на код, Travel Agent, който да помага на потребителите при планирането на пътувания, като генерира и изпълнява код. Този агент може да се справя със задачи като извличане на опции за пътуване, филтриране на резултати и съставяне на маршрут с помощта на генеративен AI.

#### Преглед на агента за генериране на код

1. **Събиране на предпочитанията на потребителя**: Събира входни данни като дестинация, дати на пътуване, бюджет и интереси.
2. **Генериране на код за извличане на данни**: Генерира кодови фрагменти за извличане на данни за полети, хотели и атракции.
3. **Изпълнение на генерирания код**: Изпълнява генерирания код за извличане на информация в реално време.
4. **Генериране на маршрут**: Съставя персонализиран план за пътуване въз основа на извлечените данни.
5. **Адаптиране според обратната връзка**: Получава обратна връзка от потребителя и регенерира код, ако е необходимо, за да подобри резултатите.

#### Стъпка по стъпка имплементация

1. **Събиране на предпочитанията на потребителя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генериране на код за извличане на данни**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Example: Generate code to search for flights based on user preferences
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Example: Generate code to search for hotels
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **Изпълнение на генерирания код**

   ```python
   def execute_code(code):
       # Execute the generated code using exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Генериране на маршрут**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Адаптиране според обратната връзка**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Adjust preferences based on user feedback
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Regenerate and execute code with updated preferences
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### Използване на осъзнаване на средата и разсъждение

Използването на схемата на таблицата може значително да подобри процеса на генериране на заявки чрез осъзнаване на средата и разсъждение.

Ето пример как това може да се направи:

1. **Разбиране на схемата**: Системата разбира схемата на таблицата и използва тази информация за основа на генерирането на заявки.
2. **Адаптиране според обратната връзка**: Системата адаптира предпочитанията на потребителя въз основа на обратната връзка и разсъждава кои полета в схемата трябва да бъдат актуализирани.
3. **Генериране и изпълнение на заявки**: Системата генерира и изпълнява заявки за извличане на актуализирани данни за полети и хотели въз основа на новите предпочитания.

Ето актуализиран пример на Python код, който включва тези концепции:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Adjust preferences based on user feedback
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Reasoning based on schema to adjust other related preferences
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Custom logic to adjust preferences based on schema and feedback
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Generate code to fetch flight data based on updated preferences
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Generate code to fetch hotel data based on updated preferences
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Simulate execution of code and return mock data
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Generate itinerary based on flights, hotels, and attractions
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Example schema
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Example usage
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Regenerate and execute code with updated preferences
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Обяснение - Резервация въз основа на обратна връзка

1. **Осъзнаване на схемата**: Речникът `schema` дефинира как предпочитанията трябва да бъдат адаптирани въз основа на обратната връзка. Той включва полета като `favorites` и `avoid` с подходящи адаптации.
2. **Адаптиране на предпочитанията (`adjust_based_on_feedback` метод)**: Този метод адаптира предпочитанията въз основа на обратната връзка от потребителя и схемата.
3. **Адаптации, базирани на средата (`adjust_based_on_environment` метод)**: Този метод персонализира адаптациите въз основа на схемата и обратната връзка.
4. **Генериране и изпълнение на заявки**: Системата генерира код за извличане на актуализирани данни за полети и хотели въз основа на адаптираните предпочитания и симулира изпълнението на тези заявки.
5. **Генериране на маршрут**: Системата създава актуализиран маршрут въз основа на новите данни за полети, хотели и атракции.

Чрез осъзнаване на средата и разсъждение въз основа на схемата, системата може да генерира по-точни и релевантни заявки, което води до по-добри препоръки за пътуване и по-персонализирано потребителско изживяване.

### Използване на SQL като техника за Retrieval-Augmented Generation (RAG)

SQL (Structured Query Language) е мощен инструмент за взаимодействие с бази данни. Когато се използва като част от подхода Retrieval-Augmented Generation (RAG), SQL може да извлича релевантни данни от бази данни, за да информира и генерира отговори или действия в AI агенти. Нека разгледаме как SQL може да се използва като RAG техника в контекста на Travel Agent.

#### Основни концепции

1. **Взаимодействие с бази данни**:
   - SQL се използва за заявяване на бази данни, извличане на релевантна информация и манипулиране на данни.
   - Пример: Извличане на детайли за полети, информация за хотели и атракции от база данни за пътувания.

2. **Интеграция с RAG**:
   - SQL заявките се генерират въз основа на входните данни и предпочитанията на потребителя.
   - Извлечените данни се използват за генериране на персонализирани препоръки или действия.

3. **Динамично генериране на заявки**:
   - AI агентът генерира динамични SQL заявки въз основа на контекста и нуждите на потребителя.
   - Пример: Персонализиране на SQL заявки за филтриране на резултати въз основа на бюджет, дати и интереси.

#### Приложения

- **Автоматизирано генериране на код**: Генериране на кодови фрагменти за конкретни задачи.
- **SQL като RAG**: Използване на SQL заявки за манипулиране на данни.
- **Решаване на проблеми**: Създаване и изпълнение на код за решаване на проблеми.

**Пример**:
Агент за анализ на данни:

1. **Задача**: Анализ на набор от данни за намиране на тенденции.
2. **Стъпки**:
   - Зареждане на набора от данни.
   - Генериране на SQL заявки за филтриране на данни.
   - Изпълнение на заявки и извличане на резултати.
   - Генериране на визуализации и прозрения.
3. **Ресурси**: Достъп до набора от данни, SQL възможности.
4. **Опит**: Използване на предишни резултати за подобряване на бъдещи анализи.

#### Практически пример: Използване на SQL в Travel Agent

1. **Събиране на предпочитанията на потребителя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генериране на SQL заявки**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **Изпълнение на SQL заявки**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Генериране на препоръки**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Примерни SQL заявки

1. **Заявка за полети**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Заявка за хотели**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Заявка за атракции**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Чрез използване на SQL като част от Retrieval-Augmented Generation (RAG) техниката, AI агенти като Travel Agent могат динамично да извличат и използват релевантни данни, за да предоставят точни и персонализирани препоръки.

### Пример за метакогниция

За да демонстрираме имплементация на метакогниция, нека създадем прост агент, който *разсъждава върху процеса си на вземане на решения*, докато решава проблем. В този пример ще изградим система, в която агентът се опитва да оптимизира избора на хотел, но след това оценява собственото си разсъждение и коригира стратегията си, когато прави грешки или субоптимални избори.

Ще симулираме това с основен пример, при който агентът избира хотели въз основа на комбинация от цена и качество, но ще "разсъждава" върху решенията си и ще се адаптира съответно.

#### Как това илюстрира метакогниция:

1. **Първоначално решение**: Агентът ще избере най-евтиния хотел, без да отчита влиянието върху качеството.
2. **Разсъждение и оценка**: След първоначалния избор агентът ще провери дали хотелът е "лош" избор въз основа на обратната връзка от потребителя. Ако установи, че качеството на хотела е твърде ниско, ще разсъждава върху разсъжденията си.
3. **Коригиране на стратегията**: Агентът ще коригира стратегията си въз основа на разсъжденията си, преминавайки от "най-евтиния" към "най-качествения", като по този начин подобрява процеса си на вземане на решения в бъдещи итерации.

Ето пример:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Stores the hotels chosen previously
        self.corrected_choices = []  # Stores the corrected choices
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Available strategies

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Let's assume we have some user feedback that tells us whether the last choice was good or not
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Adjust strategy if the previous choice was unsatisfactory
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Simulate a list of hotels (price and quality)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Create an agent
agent = HotelRecommendationAgent()

# Step 1: The agent recommends a hotel using the "cheapest" strategy
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Step 2: The agent reflects on the choice and adjusts strategy if necessary
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Step 3: The agent recommends again, this time using the adjusted strategy
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Метакогнитивни способности на агента

Ключовото тук е способността на агента да:
- Оценява предишните си избори и процеса на вземане на решения.
- Коригира стратегията си въз основа на тези разсъждения, т.е. метакогниция в действие.

Това е прост пример за метакогниция, при който системата е способна да адаптира процеса си на разсъждение въз основа на вътрешна обратна връзка.

### Заключение

Метакогницията е мощен инструмент, който може значително да подобри възможностите на AI агентите. Чрез включване на метакогнитивни процеси можете да проектирате агенти, които са по-интелигентни, адаптивни и ефективни. Използвайте допълнителните ресурси, за да изследвате по-задълбочено завладяващия свят на метакогницията в AI агентите.

### Имате още въпроси относно модела за проектиране на метакогниция?

Присъединете се към [Azure AI Foundry Discord](https://aka.ms/ai-agents/discord), за да се срещнете с други обучаващи се, да присъствате на консултации и да получите отговори на вашите въпроси за AI агентите.

## Предишен урок

[Модел за проектиране на многоагентни системи](../08-multi-agent/README.md)

## Следващ урок

[AI агенти в продукция](../10-ai-agents-production/README.md)

---

**Отказ от отговорност**:  
Този документ е преведен с помощта на AI услуга за превод [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматизираните преводи може да съдържат грешки или неточности. Оригиналният документ на неговия роден език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален човешки превод. Ние не носим отговорност за недоразумения или погрешни интерпретации, произтичащи от използването на този превод.